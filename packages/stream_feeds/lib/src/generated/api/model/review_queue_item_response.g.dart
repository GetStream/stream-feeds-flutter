// Code generated by GetStream internal OpenAPI code generator. DO NOT EDIT.

// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: use_string_in_part_of_directives
// ignore_for_file: unnecessary_raw_strings
// ignore_for_file: unnecessary_null_in_if_null_operators
// ignore_for_file: public_member_api_docs
// ignore_for_file: prefer_single_quotes
// ignore_for_file: require_trailing_commas

part of openapi.api;

@immutable
class ReviewQueueItemResponse {
  const ReviewQueueItemResponse({
    required this.actions,
    this.activity,
    required this.aiTextSeverity,
    this.assignedTo,
    required this.bans,
    this.call,
    this.completedAt,
    this.configKey,
    required this.createdAt,
    this.entityCreator,
    this.entityCreatorId,
    required this.entityId,
    required this.entityType,
    this.feedsV2Activity,
    this.feedsV2Reaction,
    required this.flags,
    required this.flagsCount,
    required this.id,
    required this.languages,
    this.message,
    this.moderationPayload,
    this.reaction,
    required this.recommendedAction,
    this.reviewedAt,
    required this.reviewedBy,
    required this.severity,
    required this.status,
    this.teams,
    required this.updatedAt,
  });

  final List<ActionLogResponse> actions;

  final EnrichedActivity? activity;

  final String aiTextSeverity;

  final UserResponse? assignedTo;

  final List<Ban> bans;

  final CallResponse? call;

  final DateTime? completedAt;

  final String? configKey;

  final DateTime createdAt;

  final EntityCreatorResponse? entityCreator;

  final String? entityCreatorId;

  final String entityId;

  final String entityType;

  final EnrichedActivity? feedsV2Activity;

  final Reaction? feedsV2Reaction;

  final List<FlagResponse> flags;

  final int flagsCount;

  final String id;

  final List<String> languages;

  final MessageResponse? message;

  final ModerationPayload? moderationPayload;

  final Reaction? reaction;

  final String recommendedAction;

  final DateTime? reviewedAt;

  final String reviewedBy;

  final int severity;

  final String status;

  final List<String>? teams;

  final DateTime updatedAt;

  Map<String, dynamic> toJson() {
    return {
      'actions': actions,
      'activity': activity,
      'ai_text_severity': aiTextSeverity,
      'assigned_to': assignedTo,
      'bans': bans,
      'call': call,
      'completed_at': completedAt,
      'config_key': configKey,
      'created_at': createdAt,
      'entity_creator': entityCreator,
      'entity_creator_id': entityCreatorId,
      'entity_id': entityId,
      'entity_type': entityType,
      'feeds_v2_activity': feedsV2Activity,
      'feeds_v2_reaction': feedsV2Reaction,
      'flags': flags,
      'flags_count': flagsCount,
      'id': id,
      'languages': languages,
      'message': message,
      'moderation_payload': moderationPayload,
      'reaction': reaction,
      'recommended_action': recommendedAction,
      'reviewed_at': reviewedAt,
      'reviewed_by': reviewedBy,
      'severity': severity,
      'status': status,
      'teams': teams,
      'updated_at': updatedAt,
    };
  }

  static ReviewQueueItemResponse? fromJson(dynamic value) {
    if (value is Map) {
      final json = value.cast<String, dynamic>();

      return ReviewQueueItemResponse(
        actions: ActionLogResponse.listFromJson(json[r'actions']),
        activity: EnrichedActivity.fromJson(json[r'activity'] ?? null),
        aiTextSeverity: mapValueOfType<String>(json, r'ai_text_severity')!,
        assignedTo: UserResponse.fromJson(json[r'assigned_to'] ?? null),
        bans: Ban.listFromJson(json[r'bans']),
        call: CallResponse.fromJson(json[r'call'] ?? null),
        completedAt: mapValueOfType<DateTime>(json, r'completed_at', null),
        configKey: mapValueOfType<String>(json, r'config_key', null),
        createdAt: mapValueOfType<DateTime>(json, r'created_at')!,
        entityCreator:
            EntityCreatorResponse.fromJson(json[r'entity_creator'] ?? null),
        entityCreatorId:
            mapValueOfType<String>(json, r'entity_creator_id', null),
        entityId: mapValueOfType<String>(json, r'entity_id')!,
        entityType: mapValueOfType<String>(json, r'entity_type')!,
        feedsV2Activity:
            EnrichedActivity.fromJson(json[r'feeds_v2_activity'] ?? null),
        feedsV2Reaction: Reaction.fromJson(json[r'feeds_v2_reaction'] ?? null),
        flags: FlagResponse.listFromJson(json[r'flags']),
        flagsCount: mapValueOfType<int>(json, r'flags_count')!,
        id: mapValueOfType<String>(json, r'id')!,
        languages: json[r'languages'] is Iterable
            ? (json[r'languages'] as Iterable)
                .cast<String>()
                .toList(growable: false)
            : const [],
        message: MessageResponse.fromJson(json[r'message'] ?? null),
        moderationPayload:
            ModerationPayload.fromJson(json[r'moderation_payload'] ?? null),
        reaction: Reaction.fromJson(json[r'reaction'] ?? null),
        recommendedAction: mapValueOfType<String>(json, r'recommended_action')!,
        reviewedAt: mapValueOfType<DateTime>(json, r'reviewed_at', null),
        reviewedBy: mapValueOfType<String>(json, r'reviewed_by')!,
        severity: mapValueOfType<int>(json, r'severity')!,
        status: mapValueOfType<String>(json, r'status')!,
        teams: json[r'teams'] is Iterable
            ? (json[r'teams'] as Iterable)
                .cast<String>()
                .toList(growable: false)
            : const [],
        updatedAt: mapValueOfType<DateTime>(json, r'updated_at')!,
      );
    }
    return null;
  }

  static List<ReviewQueueItemResponse> listFromJson(
    dynamic json, {
    bool growable = false,
  }) {
    final result = <ReviewQueueItemResponse>[];
    if (json is List && json.isNotEmpty) {
      for (final row in json) {
        final value = ReviewQueueItemResponse.fromJson(row);
        if (value != null) {
          result.add(value);
        }
      }
    }
    return result.toList(growable: growable);
  }

  @override
  String toString() {
    return 'ReviewQueueItemResponse('
        'actions: $actions, '
        'activity: $activity, '
        'aiTextSeverity: $aiTextSeverity, '
        'assignedTo: $assignedTo, '
        'bans: $bans, '
        'call: $call, '
        'completedAt: $completedAt, '
        'configKey: $configKey, '
        'createdAt: $createdAt, '
        'entityCreator: $entityCreator, '
        'entityCreatorId: $entityCreatorId, '
        'entityId: $entityId, '
        'entityType: $entityType, '
        'feedsV2Activity: $feedsV2Activity, '
        'feedsV2Reaction: $feedsV2Reaction, '
        'flags: $flags, '
        'flagsCount: $flagsCount, '
        'id: $id, '
        'languages: $languages, '
        'message: $message, '
        'moderationPayload: $moderationPayload, '
        'reaction: $reaction, '
        'recommendedAction: $recommendedAction, '
        'reviewedAt: $reviewedAt, '
        'reviewedBy: $reviewedBy, '
        'severity: $severity, '
        'status: $status, '
        'teams: $teams, '
        'updatedAt: $updatedAt, '
        ')';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is ReviewQueueItemResponse &&
        other.actions == actions &&
        other.activity == activity &&
        other.aiTextSeverity == aiTextSeverity &&
        other.assignedTo == assignedTo &&
        other.bans == bans &&
        other.call == call &&
        other.completedAt == completedAt &&
        other.configKey == configKey &&
        other.createdAt == createdAt &&
        other.entityCreator == entityCreator &&
        other.entityCreatorId == entityCreatorId &&
        other.entityId == entityId &&
        other.entityType == entityType &&
        other.feedsV2Activity == feedsV2Activity &&
        other.feedsV2Reaction == feedsV2Reaction &&
        other.flags == flags &&
        other.flagsCount == flagsCount &&
        other.id == id &&
        other.languages == languages &&
        other.message == message &&
        other.moderationPayload == moderationPayload &&
        other.reaction == reaction &&
        other.recommendedAction == recommendedAction &&
        other.reviewedAt == reviewedAt &&
        other.reviewedBy == reviewedBy &&
        other.severity == severity &&
        other.status == status &&
        other.teams == teams &&
        other.updatedAt == updatedAt;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      actions,
      activity,
      aiTextSeverity,
      assignedTo,
      bans,
      call,
      completedAt,
      configKey,
      createdAt,
      entityCreator,
      entityCreatorId,
      entityId,
      entityType,
      feedsV2Activity,
      feedsV2Reaction,
      flags,
      flagsCount,
      id,
      languages,
      message,
      moderationPayload,
      reaction,
      recommendedAction,
      reviewedAt,
      reviewedBy,
      severity,
      status,
      teams,
      updatedAt,
    ]);
  }
}
