// Code generated by GetStream internal OpenAPI code generator. DO NOT EDIT.

// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: use_string_in_part_of_directives
// ignore_for_file: unnecessary_raw_strings
// ignore_for_file: unnecessary_null_in_if_null_operators
// ignore_for_file: public_member_api_docs
// ignore_for_file: prefer_single_quotes
// ignore_for_file: require_trailing_commas

part of openapi.api;

@immutable
class OwnUser {
  const OwnUser({
    this.avgResponseTime,
    required this.banned,
    this.blockedUserIds,
    required this.channelMutes,
    required this.createdAt,
    required this.custom,
    this.deactivatedAt,
    this.deletedAt,
    required this.devices,
    required this.id,
    this.invisible,
    required this.language,
    this.lastActive,
    this.lastEngagedAt,
    this.latestHiddenChannels,
    required this.mutes,
    required this.online,
    this.privacySettings,
    this.pushPreferences,
    required this.role,
    this.teams,
    this.teamsRole,
    required this.totalUnreadCount,
    required this.totalUnreadCountByTeam,
    required this.unreadChannels,
    required this.unreadCount,
    required this.unreadThreads,
    required this.updatedAt,
  });

  final int? avgResponseTime;

  final bool banned;

  final List<String>? blockedUserIds;

  final List<ChannelMute> channelMutes;

  final DateTime createdAt;

  final Map<String, Object> custom;

  final DateTime? deactivatedAt;

  final DateTime? deletedAt;

  final List<Device> devices;

  final String id;

  final bool? invisible;

  final String language;

  final DateTime? lastActive;

  final DateTime? lastEngagedAt;

  final List<String>? latestHiddenChannels;

  final List<UserMute> mutes;

  final bool online;

  final PrivacySettings? privacySettings;

  final PushPreferences? pushPreferences;

  final String role;

  final List<String>? teams;

  final Map<String, String>? teamsRole;

  final int totalUnreadCount;

  final Map<String, int> totalUnreadCountByTeam;

  final int unreadChannels;

  final int unreadCount;

  final int unreadThreads;

  final DateTime updatedAt;

  Map<String, dynamic> toJson() {
    return {
      'avg_response_time': avgResponseTime,
      'banned': banned,
      'blocked_user_ids': blockedUserIds,
      'channel_mutes': channelMutes,
      'created_at': createdAt,
      'custom': custom,
      'deactivated_at': deactivatedAt,
      'deleted_at': deletedAt,
      'devices': devices,
      'id': id,
      'invisible': invisible,
      'language': language,
      'last_active': lastActive,
      'last_engaged_at': lastEngagedAt,
      'latest_hidden_channels': latestHiddenChannels,
      'mutes': mutes,
      'online': online,
      'privacy_settings': privacySettings,
      'push_preferences': pushPreferences,
      'role': role,
      'teams': teams,
      'teams_role': teamsRole,
      'total_unread_count': totalUnreadCount,
      'total_unread_count_by_team': totalUnreadCountByTeam,
      'unread_channels': unreadChannels,
      'unread_count': unreadCount,
      'unread_threads': unreadThreads,
      'updated_at': updatedAt,
    };
  }

  static OwnUser? fromJson(dynamic value) {
    if (value is Map) {
      final json = value.cast<String, dynamic>();

      return OwnUser(
        avgResponseTime: mapValueOfType<int>(json, r'avg_response_time', null),
        banned: mapValueOfType<bool>(json, r'banned')!,
        blockedUserIds: json[r'blocked_user_ids'] is Iterable
            ? (json[r'blocked_user_ids'] as Iterable)
                .cast<String>()
                .toList(growable: false)
            : const [],
        channelMutes: ChannelMute.listFromJson(json[r'channel_mutes']),
        createdAt: mapValueOfType<DateTime>(json, r'created_at')!,
        custom: mapCastOfType<String, Object>(json, r'custom')!,
        deactivatedAt: mapValueOfType<DateTime>(json, r'deactivated_at', null),
        deletedAt: mapValueOfType<DateTime>(json, r'deleted_at', null),
        devices: Device.listFromJson(json[r'devices']),
        id: mapValueOfType<String>(json, r'id')!,
        invisible: mapValueOfType<bool>(json, r'invisible', null),
        language: mapValueOfType<String>(json, r'language')!,
        lastActive: mapValueOfType<DateTime>(json, r'last_active', null),
        lastEngagedAt: mapValueOfType<DateTime>(json, r'last_engaged_at', null),
        latestHiddenChannels: json[r'latest_hidden_channels'] is Iterable
            ? (json[r'latest_hidden_channels'] as Iterable)
                .cast<String>()
                .toList(growable: false)
            : const [],
        mutes: UserMute.listFromJson(json[r'mutes']),
        online: mapValueOfType<bool>(json, r'online')!,
        privacySettings:
            PrivacySettings.fromJson(json[r'privacy_settings'] ?? null),
        pushPreferences:
            PushPreferences.fromJson(json[r'push_preferences'] ?? null),
        role: mapValueOfType<String>(json, r'role')!,
        teams: json[r'teams'] is Iterable
            ? (json[r'teams'] as Iterable)
                .cast<String>()
                .toList(growable: false)
            : const [],
        teamsRole: mapCastOfType<String, String>(json, r'teams_role'),
        totalUnreadCount: mapValueOfType<int>(json, r'total_unread_count')!,
        totalUnreadCountByTeam:
            mapCastOfType<String, int>(json, r'total_unread_count_by_team')!,
        unreadChannels: mapValueOfType<int>(json, r'unread_channels')!,
        unreadCount: mapValueOfType<int>(json, r'unread_count')!,
        unreadThreads: mapValueOfType<int>(json, r'unread_threads')!,
        updatedAt: mapValueOfType<DateTime>(json, r'updated_at')!,
      );
    }
    return null;
  }

  static List<OwnUser> listFromJson(
    dynamic json, {
    bool growable = false,
  }) {
    final result = <OwnUser>[];
    if (json is List && json.isNotEmpty) {
      for (final row in json) {
        final value = OwnUser.fromJson(row);
        if (value != null) {
          result.add(value);
        }
      }
    }
    return result.toList(growable: growable);
  }

  @override
  String toString() {
    return 'OwnUser('
        'avgResponseTime: $avgResponseTime, '
        'banned: $banned, '
        'blockedUserIds: $blockedUserIds, '
        'channelMutes: $channelMutes, '
        'createdAt: $createdAt, '
        'custom: $custom, '
        'deactivatedAt: $deactivatedAt, '
        'deletedAt: $deletedAt, '
        'devices: $devices, '
        'id: $id, '
        'invisible: $invisible, '
        'language: $language, '
        'lastActive: $lastActive, '
        'lastEngagedAt: $lastEngagedAt, '
        'latestHiddenChannels: $latestHiddenChannels, '
        'mutes: $mutes, '
        'online: $online, '
        'privacySettings: $privacySettings, '
        'pushPreferences: $pushPreferences, '
        'role: $role, '
        'teams: $teams, '
        'teamsRole: $teamsRole, '
        'totalUnreadCount: $totalUnreadCount, '
        'totalUnreadCountByTeam: $totalUnreadCountByTeam, '
        'unreadChannels: $unreadChannels, '
        'unreadCount: $unreadCount, '
        'unreadThreads: $unreadThreads, '
        'updatedAt: $updatedAt, '
        ')';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is OwnUser &&
        other.avgResponseTime == avgResponseTime &&
        other.banned == banned &&
        other.blockedUserIds == blockedUserIds &&
        other.channelMutes == channelMutes &&
        other.createdAt == createdAt &&
        other.custom == custom &&
        other.deactivatedAt == deactivatedAt &&
        other.deletedAt == deletedAt &&
        other.devices == devices &&
        other.id == id &&
        other.invisible == invisible &&
        other.language == language &&
        other.lastActive == lastActive &&
        other.lastEngagedAt == lastEngagedAt &&
        other.latestHiddenChannels == latestHiddenChannels &&
        other.mutes == mutes &&
        other.online == online &&
        other.privacySettings == privacySettings &&
        other.pushPreferences == pushPreferences &&
        other.role == role &&
        other.teams == teams &&
        other.teamsRole == teamsRole &&
        other.totalUnreadCount == totalUnreadCount &&
        other.totalUnreadCountByTeam == totalUnreadCountByTeam &&
        other.unreadChannels == unreadChannels &&
        other.unreadCount == unreadCount &&
        other.unreadThreads == unreadThreads &&
        other.updatedAt == updatedAt;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      avgResponseTime,
      banned,
      blockedUserIds,
      channelMutes,
      createdAt,
      custom,
      deactivatedAt,
      deletedAt,
      devices,
      id,
      invisible,
      language,
      lastActive,
      lastEngagedAt,
      latestHiddenChannels,
      mutes,
      online,
      privacySettings,
      pushPreferences,
      role,
      teams,
      teamsRole,
      totalUnreadCount,
      totalUnreadCountByTeam,
      unreadChannels,
      unreadCount,
      unreadThreads,
      updatedAt,
    ]);
  }
}
