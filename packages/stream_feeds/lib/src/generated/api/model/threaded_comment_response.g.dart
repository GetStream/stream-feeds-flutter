// Code generated by GetStream internal OpenAPI code generator. DO NOT EDIT.

// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: use_string_in_part_of_directives
// ignore_for_file: unnecessary_raw_strings
// ignore_for_file: unnecessary_null_in_if_null_operators
// ignore_for_file: public_member_api_docs
// ignore_for_file: prefer_single_quotes
// ignore_for_file: require_trailing_commas

part of openapi.api;

@immutable
class ThreadedCommentResponse {
  const ThreadedCommentResponse({
    this.attachments,
    required this.confidenceScore,
    this.controversyScore,
    required this.createdAt,
    this.custom,
    this.deletedAt,
    required this.downvoteCount,
    required this.id,
    this.latestReactions,
    required this.mentionedUsers,
    this.meta,
    this.moderation,
    required this.objectId,
    required this.objectType,
    required this.ownReactions,
    this.parentId,
    required this.reactionCount,
    this.reactionGroups,
    this.replies,
    required this.replyCount,
    required this.score,
    required this.status,
    this.text,
    required this.updatedAt,
    required this.upvoteCount,
    required this.user,
  });

  final List<Attachment>? attachments;

  final num confidenceScore;

  final num? controversyScore;

  final DateTime createdAt;

  final Map<String, Object>? custom;

  final DateTime? deletedAt;

  final int downvoteCount;

  final String id;

  final List<FeedsReactionResponse>? latestReactions;

  final List<UserResponse> mentionedUsers;

  final RepliesMeta? meta;

  final ModerationV2Response? moderation;

  final String objectId;

  final String objectType;

  final List<FeedsReactionResponse> ownReactions;

  final String? parentId;

  final int reactionCount;

  final Map<String, ReactionGroupResponse>? reactionGroups;

  final List<ThreadedCommentResponse>? replies;

  final int replyCount;

  final int score;

  final String status;

  final String? text;

  final DateTime updatedAt;

  final int upvoteCount;

  final UserResponse user;

  Map<String, dynamic> toJson() {
    return {
      'attachments': attachments,
      'confidence_score': confidenceScore,
      'controversy_score': controversyScore,
      'created_at': createdAt,
      'custom': custom,
      'deleted_at': deletedAt,
      'downvote_count': downvoteCount,
      'id': id,
      'latest_reactions': latestReactions,
      'mentioned_users': mentionedUsers,
      'meta': meta,
      'moderation': moderation,
      'object_id': objectId,
      'object_type': objectType,
      'own_reactions': ownReactions,
      'parent_id': parentId,
      'reaction_count': reactionCount,
      'reaction_groups': reactionGroups,
      'replies': replies,
      'reply_count': replyCount,
      'score': score,
      'status': status,
      'text': text,
      'updated_at': updatedAt,
      'upvote_count': upvoteCount,
      'user': user,
    };
  }

  static ThreadedCommentResponse? fromJson(dynamic value) {
    if (value is Map) {
      final json = value.cast<String, dynamic>();

      return ThreadedCommentResponse(
        attachments: Attachment.listFromJson(json[r'attachments']),
        confidenceScore: mapValueOfType<num>(json, r'confidence_score')!,
        controversyScore: mapValueOfType<num>(json, r'controversy_score', null),
        createdAt: mapValueOfType<DateTime>(json, r'created_at')!,
        custom: mapCastOfType<String, Object>(json, r'custom'),
        deletedAt: mapValueOfType<DateTime>(json, r'deleted_at', null),
        downvoteCount: mapValueOfType<int>(json, r'downvote_count')!,
        id: mapValueOfType<String>(json, r'id')!,
        latestReactions:
            FeedsReactionResponse.listFromJson(json[r'latest_reactions']),
        mentionedUsers: UserResponse.listFromJson(json[r'mentioned_users']),
        meta: RepliesMeta.fromJson(json[r'meta'] ?? null),
        moderation: ModerationV2Response.fromJson(json[r'moderation'] ?? null),
        objectId: mapValueOfType<String>(json, r'object_id')!,
        objectType: mapValueOfType<String>(json, r'object_type')!,
        ownReactions:
            FeedsReactionResponse.listFromJson(json[r'own_reactions']),
        parentId: mapValueOfType<String>(json, r'parent_id', null),
        reactionCount: mapValueOfType<int>(json, r'reaction_count')!,
        reactionGroups: mapCastOfType<String, ReactionGroupResponse>(
            json, r'reaction_groups'),
        replies: ThreadedCommentResponse.listFromJson(json[r'replies']),
        replyCount: mapValueOfType<int>(json, r'reply_count')!,
        score: mapValueOfType<int>(json, r'score')!,
        status: mapValueOfType<String>(json, r'status')!,
        text: mapValueOfType<String>(json, r'text', null),
        updatedAt: mapValueOfType<DateTime>(json, r'updated_at')!,
        upvoteCount: mapValueOfType<int>(json, r'upvote_count')!,
        user: UserResponse.fromJson(json[r'user'])!,
      );
    }
    return null;
  }

  static List<ThreadedCommentResponse> listFromJson(
    dynamic json, {
    bool growable = false,
  }) {
    final result = <ThreadedCommentResponse>[];
    if (json is List && json.isNotEmpty) {
      for (final row in json) {
        final value = ThreadedCommentResponse.fromJson(row);
        if (value != null) {
          result.add(value);
        }
      }
    }
    return result.toList(growable: growable);
  }

  @override
  String toString() {
    return 'ThreadedCommentResponse('
        'attachments: $attachments, '
        'confidenceScore: $confidenceScore, '
        'controversyScore: $controversyScore, '
        'createdAt: $createdAt, '
        'custom: $custom, '
        'deletedAt: $deletedAt, '
        'downvoteCount: $downvoteCount, '
        'id: $id, '
        'latestReactions: $latestReactions, '
        'mentionedUsers: $mentionedUsers, '
        'meta: $meta, '
        'moderation: $moderation, '
        'objectId: $objectId, '
        'objectType: $objectType, '
        'ownReactions: $ownReactions, '
        'parentId: $parentId, '
        'reactionCount: $reactionCount, '
        'reactionGroups: $reactionGroups, '
        'replies: $replies, '
        'replyCount: $replyCount, '
        'score: $score, '
        'status: $status, '
        'text: $text, '
        'updatedAt: $updatedAt, '
        'upvoteCount: $upvoteCount, '
        'user: $user, '
        ')';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is ThreadedCommentResponse &&
        other.attachments == attachments &&
        other.confidenceScore == confidenceScore &&
        other.controversyScore == controversyScore &&
        other.createdAt == createdAt &&
        other.custom == custom &&
        other.deletedAt == deletedAt &&
        other.downvoteCount == downvoteCount &&
        other.id == id &&
        other.latestReactions == latestReactions &&
        other.mentionedUsers == mentionedUsers &&
        other.meta == meta &&
        other.moderation == moderation &&
        other.objectId == objectId &&
        other.objectType == objectType &&
        other.ownReactions == ownReactions &&
        other.parentId == parentId &&
        other.reactionCount == reactionCount &&
        other.reactionGroups == reactionGroups &&
        other.replies == replies &&
        other.replyCount == replyCount &&
        other.score == score &&
        other.status == status &&
        other.text == text &&
        other.updatedAt == updatedAt &&
        other.upvoteCount == upvoteCount &&
        other.user == user;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      attachments,
      confidenceScore,
      controversyScore,
      createdAt,
      custom,
      deletedAt,
      downvoteCount,
      id,
      latestReactions,
      mentionedUsers,
      meta,
      moderation,
      objectId,
      objectType,
      ownReactions,
      parentId,
      reactionCount,
      reactionGroups,
      replies,
      replyCount,
      score,
      status,
      text,
      updatedAt,
      upvoteCount,
      user,
    ]);
  }
}
