// Code generated by GetStream internal OpenAPI code generator. DO NOT EDIT.

// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: use_string_in_part_of_directives
// ignore_for_file: unnecessary_raw_strings
// ignore_for_file: unnecessary_null_in_if_null_operators
// ignore_for_file: public_member_api_docs
// ignore_for_file: prefer_single_quotes
// ignore_for_file: require_trailing_commas

part of openapi.api;

@immutable
class CallSettings {
  const CallSettings({
    this.audio,
    this.backstage,
    this.broadcasting,
    this.frameRecording,
    this.geofencing,
    this.limits,
    this.recording,
    this.ring,
    this.screensharing,
    this.session,
    this.thumbnails,
    this.transcription,
    this.video,
  });

  final AudioSettings? audio;

  final BackstageSettings? backstage;

  final BroadcastSettings? broadcasting;

  final FrameRecordSettings? frameRecording;

  final GeofenceSettings? geofencing;

  final LimitsSettings? limits;

  final RecordSettings? recording;

  final RingSettings? ring;

  final ScreensharingSettings? screensharing;

  final SessionSettings? session;

  final ThumbnailsSettings? thumbnails;

  final TranscriptionSettings? transcription;

  final VideoSettings? video;

  Map<String, dynamic> toJson() {
    return {
      'audio': audio,
      'backstage': backstage,
      'broadcasting': broadcasting,
      'frame_recording': frameRecording,
      'geofencing': geofencing,
      'limits': limits,
      'recording': recording,
      'ring': ring,
      'screensharing': screensharing,
      'session': session,
      'thumbnails': thumbnails,
      'transcription': transcription,
      'video': video,
    };
  }

  static CallSettings? fromJson(dynamic value) {
    if (value is Map) {
      final json = value.cast<String, dynamic>();

      return CallSettings(
        audio: AudioSettings.fromJson(json[r'audio'] ?? null),
        backstage: BackstageSettings.fromJson(json[r'backstage'] ?? null),
        broadcasting: BroadcastSettings.fromJson(json[r'broadcasting'] ?? null),
        frameRecording:
            FrameRecordSettings.fromJson(json[r'frame_recording'] ?? null),
        geofencing: GeofenceSettings.fromJson(json[r'geofencing'] ?? null),
        limits: LimitsSettings.fromJson(json[r'limits'] ?? null),
        recording: RecordSettings.fromJson(json[r'recording'] ?? null),
        ring: RingSettings.fromJson(json[r'ring'] ?? null),
        screensharing:
            ScreensharingSettings.fromJson(json[r'screensharing'] ?? null),
        session: SessionSettings.fromJson(json[r'session'] ?? null),
        thumbnails: ThumbnailsSettings.fromJson(json[r'thumbnails'] ?? null),
        transcription:
            TranscriptionSettings.fromJson(json[r'transcription'] ?? null),
        video: VideoSettings.fromJson(json[r'video'] ?? null),
      );
    }
    return null;
  }

  static List<CallSettings> listFromJson(
    dynamic json, {
    bool growable = false,
  }) {
    final result = <CallSettings>[];
    if (json is List && json.isNotEmpty) {
      for (final row in json) {
        final value = CallSettings.fromJson(row);
        if (value != null) {
          result.add(value);
        }
      }
    }
    return result.toList(growable: growable);
  }

  @override
  String toString() {
    return 'CallSettings('
        'audio: $audio, '
        'backstage: $backstage, '
        'broadcasting: $broadcasting, '
        'frameRecording: $frameRecording, '
        'geofencing: $geofencing, '
        'limits: $limits, '
        'recording: $recording, '
        'ring: $ring, '
        'screensharing: $screensharing, '
        'session: $session, '
        'thumbnails: $thumbnails, '
        'transcription: $transcription, '
        'video: $video, '
        ')';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is CallSettings &&
        other.audio == audio &&
        other.backstage == backstage &&
        other.broadcasting == broadcasting &&
        other.frameRecording == frameRecording &&
        other.geofencing == geofencing &&
        other.limits == limits &&
        other.recording == recording &&
        other.ring == ring &&
        other.screensharing == screensharing &&
        other.session == session &&
        other.thumbnails == thumbnails &&
        other.transcription == transcription &&
        other.video == video;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      audio,
      backstage,
      broadcasting,
      frameRecording,
      geofencing,
      limits,
      recording,
      ring,
      screensharing,
      session,
      thumbnails,
      transcription,
      video,
    ]);
  }
}
