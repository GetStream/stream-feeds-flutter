// Code generated by GetStream internal OpenAPI code generator. DO NOT EDIT.

// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: use_string_in_part_of_directives
// ignore_for_file: unnecessary_raw_strings
// ignore_for_file: unnecessary_null_in_if_null_operators
// ignore_for_file: public_member_api_docs
// ignore_for_file: prefer_single_quotes
// ignore_for_file: require_trailing_commas

part of openapi.api;

enum ChannelConfigAutomodEnum {
  aI('AI'),
  disabled('disabled'),
  simple('simple'),
  unknown('_unknown');

  const ChannelConfigAutomodEnum(this.value);
  final String value;

  static ChannelConfigAutomodEnum? fromValue(String? json) {
    switch (json) {
      case null:
        return null;
      case 'AI':
        return ChannelConfigAutomodEnum.aI;
      case 'disabled':
        return ChannelConfigAutomodEnum.disabled;
      case 'simple':
        return ChannelConfigAutomodEnum.simple;
      default:
        return ChannelConfigAutomodEnum.unknown;
    }
  }
}

enum ChannelConfigAutomodBehaviorEnum {
  block('block'),
  flag('flag'),
  shadowBlock('shadow_block'),
  unknown('_unknown');

  const ChannelConfigAutomodBehaviorEnum(this.value);
  final String value;

  static ChannelConfigAutomodBehaviorEnum? fromValue(String? json) {
    switch (json) {
      case null:
        return null;
      case 'block':
        return ChannelConfigAutomodBehaviorEnum.block;
      case 'flag':
        return ChannelConfigAutomodBehaviorEnum.flag;
      case 'shadow_block':
        return ChannelConfigAutomodBehaviorEnum.shadowBlock;
      default:
        return ChannelConfigAutomodBehaviorEnum.unknown;
    }
  }
}

enum ChannelConfigBlocklistBehaviorEnum {
  block('block'),
  flag('flag'),
  shadowBlock('shadow_block'),
  unknown('_unknown');

  const ChannelConfigBlocklistBehaviorEnum(this.value);
  final String value;

  static ChannelConfigBlocklistBehaviorEnum? fromValue(String? json) {
    switch (json) {
      case null:
        return null;
      case 'block':
        return ChannelConfigBlocklistBehaviorEnum.block;
      case 'flag':
        return ChannelConfigBlocklistBehaviorEnum.flag;
      case 'shadow_block':
        return ChannelConfigBlocklistBehaviorEnum.shadowBlock;
      default:
        return ChannelConfigBlocklistBehaviorEnum.unknown;
    }
  }
}

@immutable
class ChannelConfig {
  const ChannelConfig({
    this.allowedFlagReasons,
    required this.automod,
    required this.automodBehavior,
    this.automodThresholds,
    this.blocklist,
    this.blocklistBehavior,
    this.blocklists,
    required this.commands,
    required this.connectEvents,
    required this.createdAt,
    required this.customEvents,
    required this.markMessagesPending,
    required this.maxMessageLength,
    required this.mutes,
    required this.name,
    this.partitionSize,
    this.partitionTtl,
    required this.polls,
    required this.pushNotifications,
    required this.quotes,
    required this.reactions,
    required this.readEvents,
    required this.reminders,
    required this.replies,
    required this.search,
    required this.sharedLocations,
    required this.skipLastMsgUpdateForSystemMsgs,
    required this.typingEvents,
    required this.updatedAt,
    required this.uploads,
    required this.urlEnrichment,
    required this.userMessageReminders,
  });

  final List<String>? allowedFlagReasons;

  final ChannelConfigAutomodEnum automod;

  final ChannelConfigAutomodBehaviorEnum automodBehavior;

  final Thresholds? automodThresholds;

  final String? blocklist;

  final ChannelConfigBlocklistBehaviorEnum? blocklistBehavior;

  final List<BlockListOptions>? blocklists;

  final List<String> commands;

  final bool connectEvents;

  final DateTime createdAt;

  final bool customEvents;

  final bool markMessagesPending;

  final int maxMessageLength;

  final bool mutes;

  final String name;

  final int? partitionSize;

  final int? partitionTtl;

  final bool polls;

  final bool pushNotifications;

  final bool quotes;

  final bool reactions;

  final bool readEvents;

  final bool reminders;

  final bool replies;

  final bool search;

  final bool sharedLocations;

  final bool skipLastMsgUpdateForSystemMsgs;

  final bool typingEvents;

  final DateTime updatedAt;

  final bool uploads;

  final bool urlEnrichment;

  final bool userMessageReminders;

  Map<String, dynamic> toJson() {
    return {
      'allowed_flag_reasons': allowedFlagReasons,
      'automod': automod,
      'automod_behavior': automodBehavior,
      'automod_thresholds': automodThresholds,
      'blocklist': blocklist,
      'blocklist_behavior': blocklistBehavior,
      'blocklists': blocklists,
      'commands': commands,
      'connect_events': connectEvents,
      'created_at': createdAt,
      'custom_events': customEvents,
      'mark_messages_pending': markMessagesPending,
      'max_message_length': maxMessageLength,
      'mutes': mutes,
      'name': name,
      'partition_size': partitionSize,
      'partition_ttl': partitionTtl,
      'polls': polls,
      'push_notifications': pushNotifications,
      'quotes': quotes,
      'reactions': reactions,
      'read_events': readEvents,
      'reminders': reminders,
      'replies': replies,
      'search': search,
      'shared_locations': sharedLocations,
      'skip_last_msg_update_for_system_msgs': skipLastMsgUpdateForSystemMsgs,
      'typing_events': typingEvents,
      'updated_at': updatedAt,
      'uploads': uploads,
      'url_enrichment': urlEnrichment,
      'user_message_reminders': userMessageReminders,
    };
  }

  static ChannelConfig? fromJson(dynamic value) {
    if (value is Map) {
      final json = value.cast<String, dynamic>();

      return ChannelConfig(
        allowedFlagReasons: json[r'allowed_flag_reasons'] is Iterable
            ? (json[r'allowed_flag_reasons'] as Iterable)
                .cast<String>()
                .toList(growable: false)
            : const [],
        automod: ChannelConfigAutomodEnum.fromValue(json['automod'])!,
        automodBehavior: ChannelConfigAutomodBehaviorEnum.fromValue(
            json['automod_behavior'])!,
        automodThresholds:
            Thresholds.fromJson(json[r'automod_thresholds'] ?? null),
        blocklist: mapValueOfType<String>(json, r'blocklist', null),
        blocklistBehavior: ChannelConfigBlocklistBehaviorEnum.fromValue(
            json['blocklist_behavior']),
        blocklists: BlockListOptions.listFromJson(json[r'blocklists']),
        commands: json[r'commands'] is Iterable
            ? (json[r'commands'] as Iterable)
                .cast<String>()
                .toList(growable: false)
            : const [],
        connectEvents: mapValueOfType<bool>(json, r'connect_events')!,
        createdAt: mapValueOfType<DateTime>(json, r'created_at')!,
        customEvents: mapValueOfType<bool>(json, r'custom_events')!,
        markMessagesPending:
            mapValueOfType<bool>(json, r'mark_messages_pending')!,
        maxMessageLength: mapValueOfType<int>(json, r'max_message_length')!,
        mutes: mapValueOfType<bool>(json, r'mutes')!,
        name: mapValueOfType<String>(json, r'name')!,
        partitionSize: mapValueOfType<int>(json, r'partition_size', null),
        partitionTtl: mapValueOfType<int>(json, r'partition_ttl', null),
        polls: mapValueOfType<bool>(json, r'polls')!,
        pushNotifications: mapValueOfType<bool>(json, r'push_notifications')!,
        quotes: mapValueOfType<bool>(json, r'quotes')!,
        reactions: mapValueOfType<bool>(json, r'reactions')!,
        readEvents: mapValueOfType<bool>(json, r'read_events')!,
        reminders: mapValueOfType<bool>(json, r'reminders')!,
        replies: mapValueOfType<bool>(json, r'replies')!,
        search: mapValueOfType<bool>(json, r'search')!,
        sharedLocations: mapValueOfType<bool>(json, r'shared_locations')!,
        skipLastMsgUpdateForSystemMsgs: mapValueOfType<bool>(
            json, r'skip_last_msg_update_for_system_msgs')!,
        typingEvents: mapValueOfType<bool>(json, r'typing_events')!,
        updatedAt: mapValueOfType<DateTime>(json, r'updated_at')!,
        uploads: mapValueOfType<bool>(json, r'uploads')!,
        urlEnrichment: mapValueOfType<bool>(json, r'url_enrichment')!,
        userMessageReminders:
            mapValueOfType<bool>(json, r'user_message_reminders')!,
      );
    }
    return null;
  }

  static List<ChannelConfig> listFromJson(
    dynamic json, {
    bool growable = false,
  }) {
    final result = <ChannelConfig>[];
    if (json is List && json.isNotEmpty) {
      for (final row in json) {
        final value = ChannelConfig.fromJson(row);
        if (value != null) {
          result.add(value);
        }
      }
    }
    return result.toList(growable: growable);
  }

  @override
  String toString() {
    return 'ChannelConfig('
        'allowedFlagReasons: $allowedFlagReasons, '
        'automod: $automod, '
        'automodBehavior: $automodBehavior, '
        'automodThresholds: $automodThresholds, '
        'blocklist: $blocklist, '
        'blocklistBehavior: $blocklistBehavior, '
        'blocklists: $blocklists, '
        'commands: $commands, '
        'connectEvents: $connectEvents, '
        'createdAt: $createdAt, '
        'customEvents: $customEvents, '
        'markMessagesPending: $markMessagesPending, '
        'maxMessageLength: $maxMessageLength, '
        'mutes: $mutes, '
        'name: $name, '
        'partitionSize: $partitionSize, '
        'partitionTtl: $partitionTtl, '
        'polls: $polls, '
        'pushNotifications: $pushNotifications, '
        'quotes: $quotes, '
        'reactions: $reactions, '
        'readEvents: $readEvents, '
        'reminders: $reminders, '
        'replies: $replies, '
        'search: $search, '
        'sharedLocations: $sharedLocations, '
        'skipLastMsgUpdateForSystemMsgs: $skipLastMsgUpdateForSystemMsgs, '
        'typingEvents: $typingEvents, '
        'updatedAt: $updatedAt, '
        'uploads: $uploads, '
        'urlEnrichment: $urlEnrichment, '
        'userMessageReminders: $userMessageReminders, '
        ')';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is ChannelConfig &&
        other.allowedFlagReasons == allowedFlagReasons &&
        other.automod == automod &&
        other.automodBehavior == automodBehavior &&
        other.automodThresholds == automodThresholds &&
        other.blocklist == blocklist &&
        other.blocklistBehavior == blocklistBehavior &&
        other.blocklists == blocklists &&
        other.commands == commands &&
        other.connectEvents == connectEvents &&
        other.createdAt == createdAt &&
        other.customEvents == customEvents &&
        other.markMessagesPending == markMessagesPending &&
        other.maxMessageLength == maxMessageLength &&
        other.mutes == mutes &&
        other.name == name &&
        other.partitionSize == partitionSize &&
        other.partitionTtl == partitionTtl &&
        other.polls == polls &&
        other.pushNotifications == pushNotifications &&
        other.quotes == quotes &&
        other.reactions == reactions &&
        other.readEvents == readEvents &&
        other.reminders == reminders &&
        other.replies == replies &&
        other.search == search &&
        other.sharedLocations == sharedLocations &&
        other.skipLastMsgUpdateForSystemMsgs ==
            skipLastMsgUpdateForSystemMsgs &&
        other.typingEvents == typingEvents &&
        other.updatedAt == updatedAt &&
        other.uploads == uploads &&
        other.urlEnrichment == urlEnrichment &&
        other.userMessageReminders == userMessageReminders;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      allowedFlagReasons,
      automod,
      automodBehavior,
      automodThresholds,
      blocklist,
      blocklistBehavior,
      blocklists,
      commands,
      connectEvents,
      createdAt,
      customEvents,
      markMessagesPending,
      maxMessageLength,
      mutes,
      name,
      partitionSize,
      partitionTtl,
      polls,
      pushNotifications,
      quotes,
      reactions,
      readEvents,
      reminders,
      replies,
      search,
      sharedLocations,
      skipLastMsgUpdateForSystemMsgs,
      typingEvents,
      updatedAt,
      uploads,
      urlEnrichment,
      userMessageReminders,
    ]);
  }
}
