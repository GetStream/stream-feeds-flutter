// Code generated by GetStream internal OpenAPI code generator. DO NOT EDIT.

// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: use_string_in_part_of_directives
// ignore_for_file: unnecessary_raw_strings
// ignore_for_file: unnecessary_null_in_if_null_operators
// ignore_for_file: public_member_api_docs
// ignore_for_file: prefer_single_quotes
// ignore_for_file: require_trailing_commas

part of openapi.api;

@immutable
class FullUserResponse {
  const FullUserResponse({
    this.avgResponseTime,
    this.banExpires,
    required this.banned,
    required this.blockedUserIds,
    required this.channelMutes,
    required this.createdAt,
    required this.custom,
    this.deactivatedAt,
    this.deletedAt,
    required this.devices,
    required this.id,
    this.image,
    required this.invisible,
    required this.language,
    this.lastActive,
    this.latestHiddenChannels,
    required this.mutes,
    this.name,
    required this.online,
    this.privacySettings,
    this.revokeTokensIssuedBefore,
    required this.role,
    required this.shadowBanned,
    required this.teams,
    this.teamsRole,
    required this.totalUnreadCount,
    required this.unreadChannels,
    required this.unreadCount,
    required this.unreadThreads,
    required this.updatedAt,
  });

  final int? avgResponseTime;

  final DateTime? banExpires;

  final bool banned;

  final List<String> blockedUserIds;

  final List<ChannelMute> channelMutes;

  final DateTime createdAt;

  final Map<String, Object> custom;

  final DateTime? deactivatedAt;

  final DateTime? deletedAt;

  final List<DeviceResponse> devices;

  final String id;

  final String? image;

  final bool invisible;

  final String language;

  final DateTime? lastActive;

  final List<String>? latestHiddenChannels;

  final List<UserMuteResponse> mutes;

  final String? name;

  final bool online;

  final PrivacySettingsResponse? privacySettings;

  final DateTime? revokeTokensIssuedBefore;

  final String role;

  final bool shadowBanned;

  final List<String> teams;

  final Map<String, String>? teamsRole;

  final int totalUnreadCount;

  final int unreadChannels;

  final int unreadCount;

  final int unreadThreads;

  final DateTime updatedAt;

  Map<String, dynamic> toJson() {
    return {
      'avg_response_time': avgResponseTime,
      'ban_expires': banExpires,
      'banned': banned,
      'blocked_user_ids': blockedUserIds,
      'channel_mutes': channelMutes,
      'created_at': createdAt,
      'custom': custom,
      'deactivated_at': deactivatedAt,
      'deleted_at': deletedAt,
      'devices': devices,
      'id': id,
      'image': image,
      'invisible': invisible,
      'language': language,
      'last_active': lastActive,
      'latest_hidden_channels': latestHiddenChannels,
      'mutes': mutes,
      'name': name,
      'online': online,
      'privacy_settings': privacySettings,
      'revoke_tokens_issued_before': revokeTokensIssuedBefore,
      'role': role,
      'shadow_banned': shadowBanned,
      'teams': teams,
      'teams_role': teamsRole,
      'total_unread_count': totalUnreadCount,
      'unread_channels': unreadChannels,
      'unread_count': unreadCount,
      'unread_threads': unreadThreads,
      'updated_at': updatedAt,
    };
  }

  static FullUserResponse? fromJson(dynamic value) {
    if (value is Map) {
      final json = value.cast<String, dynamic>();

      return FullUserResponse(
        avgResponseTime: mapValueOfType<int>(json, r'avg_response_time', null),
        banExpires: mapValueOfType<DateTime>(json, r'ban_expires', null),
        banned: mapValueOfType<bool>(json, r'banned')!,
        blockedUserIds: json[r'blocked_user_ids'] is Iterable
            ? (json[r'blocked_user_ids'] as Iterable)
                .cast<String>()
                .toList(growable: false)
            : const [],
        channelMutes: ChannelMute.listFromJson(json[r'channel_mutes']),
        createdAt: mapValueOfType<DateTime>(json, r'created_at')!,
        custom: mapCastOfType<String, Object>(json, r'custom')!,
        deactivatedAt: mapValueOfType<DateTime>(json, r'deactivated_at', null),
        deletedAt: mapValueOfType<DateTime>(json, r'deleted_at', null),
        devices: DeviceResponse.listFromJson(json[r'devices']),
        id: mapValueOfType<String>(json, r'id')!,
        image: mapValueOfType<String>(json, r'image', null),
        invisible: mapValueOfType<bool>(json, r'invisible')!,
        language: mapValueOfType<String>(json, r'language')!,
        lastActive: mapValueOfType<DateTime>(json, r'last_active', null),
        latestHiddenChannels: json[r'latest_hidden_channels'] is Iterable
            ? (json[r'latest_hidden_channels'] as Iterable)
                .cast<String>()
                .toList(growable: false)
            : const [],
        mutes: UserMuteResponse.listFromJson(json[r'mutes']),
        name: mapValueOfType<String>(json, r'name', null),
        online: mapValueOfType<bool>(json, r'online')!,
        privacySettings:
            PrivacySettingsResponse.fromJson(json[r'privacy_settings'] ?? null),
        revokeTokensIssuedBefore: mapValueOfType<DateTime>(
            json, r'revoke_tokens_issued_before', null),
        role: mapValueOfType<String>(json, r'role')!,
        shadowBanned: mapValueOfType<bool>(json, r'shadow_banned')!,
        teams: json[r'teams'] is Iterable
            ? (json[r'teams'] as Iterable)
                .cast<String>()
                .toList(growable: false)
            : const [],
        teamsRole: mapCastOfType<String, String>(json, r'teams_role'),
        totalUnreadCount: mapValueOfType<int>(json, r'total_unread_count')!,
        unreadChannels: mapValueOfType<int>(json, r'unread_channels')!,
        unreadCount: mapValueOfType<int>(json, r'unread_count')!,
        unreadThreads: mapValueOfType<int>(json, r'unread_threads')!,
        updatedAt: mapValueOfType<DateTime>(json, r'updated_at')!,
      );
    }
    return null;
  }

  static List<FullUserResponse> listFromJson(
    dynamic json, {
    bool growable = false,
  }) {
    final result = <FullUserResponse>[];
    if (json is List && json.isNotEmpty) {
      for (final row in json) {
        final value = FullUserResponse.fromJson(row);
        if (value != null) {
          result.add(value);
        }
      }
    }
    return result.toList(growable: growable);
  }

  @override
  String toString() {
    return 'FullUserResponse('
        'avgResponseTime: $avgResponseTime, '
        'banExpires: $banExpires, '
        'banned: $banned, '
        'blockedUserIds: $blockedUserIds, '
        'channelMutes: $channelMutes, '
        'createdAt: $createdAt, '
        'custom: $custom, '
        'deactivatedAt: $deactivatedAt, '
        'deletedAt: $deletedAt, '
        'devices: $devices, '
        'id: $id, '
        'image: $image, '
        'invisible: $invisible, '
        'language: $language, '
        'lastActive: $lastActive, '
        'latestHiddenChannels: $latestHiddenChannels, '
        'mutes: $mutes, '
        'name: $name, '
        'online: $online, '
        'privacySettings: $privacySettings, '
        'revokeTokensIssuedBefore: $revokeTokensIssuedBefore, '
        'role: $role, '
        'shadowBanned: $shadowBanned, '
        'teams: $teams, '
        'teamsRole: $teamsRole, '
        'totalUnreadCount: $totalUnreadCount, '
        'unreadChannels: $unreadChannels, '
        'unreadCount: $unreadCount, '
        'unreadThreads: $unreadThreads, '
        'updatedAt: $updatedAt, '
        ')';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is FullUserResponse &&
        other.avgResponseTime == avgResponseTime &&
        other.banExpires == banExpires &&
        other.banned == banned &&
        other.blockedUserIds == blockedUserIds &&
        other.channelMutes == channelMutes &&
        other.createdAt == createdAt &&
        other.custom == custom &&
        other.deactivatedAt == deactivatedAt &&
        other.deletedAt == deletedAt &&
        other.devices == devices &&
        other.id == id &&
        other.image == image &&
        other.invisible == invisible &&
        other.language == language &&
        other.lastActive == lastActive &&
        other.latestHiddenChannels == latestHiddenChannels &&
        other.mutes == mutes &&
        other.name == name &&
        other.online == online &&
        other.privacySettings == privacySettings &&
        other.revokeTokensIssuedBefore == revokeTokensIssuedBefore &&
        other.role == role &&
        other.shadowBanned == shadowBanned &&
        other.teams == teams &&
        other.teamsRole == teamsRole &&
        other.totalUnreadCount == totalUnreadCount &&
        other.unreadChannels == unreadChannels &&
        other.unreadCount == unreadCount &&
        other.unreadThreads == unreadThreads &&
        other.updatedAt == updatedAt;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      avgResponseTime,
      banExpires,
      banned,
      blockedUserIds,
      channelMutes,
      createdAt,
      custom,
      deactivatedAt,
      deletedAt,
      devices,
      id,
      image,
      invisible,
      language,
      lastActive,
      latestHiddenChannels,
      mutes,
      name,
      online,
      privacySettings,
      revokeTokensIssuedBefore,
      role,
      shadowBanned,
      teams,
      teamsRole,
      totalUnreadCount,
      unreadChannels,
      unreadCount,
      unreadThreads,
      updatedAt,
    ]);
  }
}
