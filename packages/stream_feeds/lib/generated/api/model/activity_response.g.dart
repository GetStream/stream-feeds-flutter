// Code generated by GetStream internal OpenAPI code generator. DO NOT EDIT.

// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: use_string_in_part_of_directives
// ignore_for_file: unnecessary_raw_strings
// ignore_for_file: unnecessary_null_in_if_null_operators
// ignore_for_file: public_member_api_docs
// ignore_for_file: prefer_single_quotes
// ignore_for_file: require_trailing_commas

part of openapi.api;

enum ActivityResponseVisibilityEnum {
  private('private'),
  public('public'),
  tag('tag'),
  unknown('_unknown');

  const ActivityResponseVisibilityEnum(this.value);
  final String value;

  static ActivityResponseVisibilityEnum? fromValue(String? json) {
    switch (json) {
      case null:
        return null;
      case 'private':
        return ActivityResponseVisibilityEnum.private;
      case 'public':
        return ActivityResponseVisibilityEnum.public;
      case 'tag':
        return ActivityResponseVisibilityEnum.tag;
      default:
        return ActivityResponseVisibilityEnum.unknown;
    }
  }
}

@immutable
class ActivityResponse {
  const ActivityResponse({
    required this.attachments,
    required this.bookmarkCount,
    required this.commentCount,
    required this.comments,
    required this.createdAt,
    this.currentFeed,
    required this.custom,
    this.deletedAt,
    this.editedAt,
    this.expiresAt,
    required this.feeds,
    required this.filterTags,
    required this.id,
    required this.interestTags,
    required this.latestReactions,
    this.location,
    required this.mentionedUsers,
    this.moderation,
    this.object,
    required this.ownBookmarks,
    required this.ownReactions,
    this.parent,
    this.poll,
    required this.popularity,
    required this.reactionCount,
    required this.reactionGroups,
    required this.score,
    required this.searchData,
    required this.shareCount,
    this.text,
    required this.type,
    required this.updatedAt,
    required this.user,
    required this.visibility,
    this.visibilityTag,
  });

  final List<Attachment> attachments;

  final int bookmarkCount;

  final int commentCount;

  final List<CommentResponse> comments;

  final DateTime createdAt;

  final FeedResponse? currentFeed;

  final Map<String, Object> custom;

  final DateTime? deletedAt;

  final DateTime? editedAt;

  final DateTime? expiresAt;

  final List<String> feeds;

  final List<String> filterTags;

  final String id;

  final List<String> interestTags;

  final List<FeedsReactionResponse> latestReactions;

  final ActivityLocation? location;

  final List<UserResponse> mentionedUsers;

  final ModerationV2Response? moderation;

  final Map<String, Object>? object;

  final List<BookmarkResponse> ownBookmarks;

  final List<FeedsReactionResponse> ownReactions;

  final ActivityResponse? parent;

  final PollResponseData? poll;

  final int popularity;

  final int reactionCount;

  final Map<String, ReactionGroupResponse> reactionGroups;

  final num score;

  final Map<String, Object> searchData;

  final int shareCount;

  final String? text;

  final String type;

  final DateTime updatedAt;

  final UserResponse user;

  final ActivityResponseVisibilityEnum visibility;

  final String? visibilityTag;

  Map<String, dynamic> toJson() {
    return {
      'attachments': attachments,
      'bookmark_count': bookmarkCount,
      'comment_count': commentCount,
      'comments': comments,
      'created_at': createdAt,
      'current_feed': currentFeed,
      'custom': custom,
      'deleted_at': deletedAt,
      'edited_at': editedAt,
      'expires_at': expiresAt,
      'feeds': feeds,
      'filter_tags': filterTags,
      'id': id,
      'interest_tags': interestTags,
      'latest_reactions': latestReactions,
      'location': location,
      'mentioned_users': mentionedUsers,
      'moderation': moderation,
      'object': object,
      'own_bookmarks': ownBookmarks,
      'own_reactions': ownReactions,
      'parent': parent,
      'poll': poll,
      'popularity': popularity,
      'reaction_count': reactionCount,
      'reaction_groups': reactionGroups,
      'score': score,
      'search_data': searchData,
      'share_count': shareCount,
      'text': text,
      'type': type,
      'updated_at': updatedAt,
      'user': user,
      'visibility': visibility,
      'visibility_tag': visibilityTag,
    };
  }

  static ActivityResponse? fromJson(dynamic value) {
    if (value is Map) {
      final json = value.cast<String, dynamic>();

      return ActivityResponse(
        attachments: Attachment.listFromJson(json[r'attachments']),
        bookmarkCount: mapValueOfType<int>(json, r'bookmark_count')!,
        commentCount: mapValueOfType<int>(json, r'comment_count')!,
        comments: CommentResponse.listFromJson(json[r'comments']),
        createdAt: mapValueOfType<DateTime>(json, r'created_at')!,
        currentFeed: FeedResponse.fromJson(json[r'current_feed'] ?? null),
        custom: mapCastOfType<String, Object>(json, r'custom')!,
        deletedAt: mapValueOfType<DateTime>(json, r'deleted_at', null),
        editedAt: mapValueOfType<DateTime>(json, r'edited_at', null),
        expiresAt: mapValueOfType<DateTime>(json, r'expires_at', null),
        feeds: json[r'feeds'] is Iterable
            ? (json[r'feeds'] as Iterable)
                .cast<String>()
                .toList(growable: false)
            : const [],
        filterTags: json[r'filter_tags'] is Iterable
            ? (json[r'filter_tags'] as Iterable)
                .cast<String>()
                .toList(growable: false)
            : const [],
        id: mapValueOfType<String>(json, r'id')!,
        interestTags: json[r'interest_tags'] is Iterable
            ? (json[r'interest_tags'] as Iterable)
                .cast<String>()
                .toList(growable: false)
            : const [],
        latestReactions:
            FeedsReactionResponse.listFromJson(json[r'latest_reactions']),
        location: ActivityLocation.fromJson(json[r'location'] ?? null),
        mentionedUsers: UserResponse.listFromJson(json[r'mentioned_users']),
        moderation: ModerationV2Response.fromJson(json[r'moderation'] ?? null),
        object: mapCastOfType<String, Object>(json, r'object'),
        ownBookmarks: BookmarkResponse.listFromJson(json[r'own_bookmarks']),
        ownReactions:
            FeedsReactionResponse.listFromJson(json[r'own_reactions']),
        parent: ActivityResponse.fromJson(json[r'parent'] ?? null),
        poll: PollResponseData.fromJson(json[r'poll'] ?? null),
        popularity: mapValueOfType<int>(json, r'popularity')!,
        reactionCount: mapValueOfType<int>(json, r'reaction_count')!,
        reactionGroups: mapCastOfType<String, ReactionGroupResponse>(
            json, r'reaction_groups')!,
        score: mapValueOfType<num>(json, r'score')!,
        searchData: mapCastOfType<String, Object>(json, r'search_data')!,
        shareCount: mapValueOfType<int>(json, r'share_count')!,
        text: mapValueOfType<String>(json, r'text', null),
        type: mapValueOfType<String>(json, r'type')!,
        updatedAt: mapValueOfType<DateTime>(json, r'updated_at')!,
        user: UserResponse.fromJson(json[r'user'])!,
        visibility:
            ActivityResponseVisibilityEnum.fromValue(json['visibility'])!,
        visibilityTag: mapValueOfType<String>(json, r'visibility_tag', null),
      );
    }
    return null;
  }

  static List<ActivityResponse> listFromJson(
    dynamic json, {
    bool growable = false,
  }) {
    final result = <ActivityResponse>[];
    if (json is List && json.isNotEmpty) {
      for (final row in json) {
        final value = ActivityResponse.fromJson(row);
        if (value != null) {
          result.add(value);
        }
      }
    }
    return result.toList(growable: growable);
  }

  @override
  String toString() {
    return 'ActivityResponse('
        'attachments: $attachments, '
        'bookmarkCount: $bookmarkCount, '
        'commentCount: $commentCount, '
        'comments: $comments, '
        'createdAt: $createdAt, '
        'currentFeed: $currentFeed, '
        'custom: $custom, '
        'deletedAt: $deletedAt, '
        'editedAt: $editedAt, '
        'expiresAt: $expiresAt, '
        'feeds: $feeds, '
        'filterTags: $filterTags, '
        'id: $id, '
        'interestTags: $interestTags, '
        'latestReactions: $latestReactions, '
        'location: $location, '
        'mentionedUsers: $mentionedUsers, '
        'moderation: $moderation, '
        'object: $object, '
        'ownBookmarks: $ownBookmarks, '
        'ownReactions: $ownReactions, '
        'parent: $parent, '
        'poll: $poll, '
        'popularity: $popularity, '
        'reactionCount: $reactionCount, '
        'reactionGroups: $reactionGroups, '
        'score: $score, '
        'searchData: $searchData, '
        'shareCount: $shareCount, '
        'text: $text, '
        'type: $type, '
        'updatedAt: $updatedAt, '
        'user: $user, '
        'visibility: $visibility, '
        'visibilityTag: $visibilityTag, '
        ')';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is ActivityResponse &&
        other.attachments == attachments &&
        other.bookmarkCount == bookmarkCount &&
        other.commentCount == commentCount &&
        other.comments == comments &&
        other.createdAt == createdAt &&
        other.currentFeed == currentFeed &&
        other.custom == custom &&
        other.deletedAt == deletedAt &&
        other.editedAt == editedAt &&
        other.expiresAt == expiresAt &&
        other.feeds == feeds &&
        other.filterTags == filterTags &&
        other.id == id &&
        other.interestTags == interestTags &&
        other.latestReactions == latestReactions &&
        other.location == location &&
        other.mentionedUsers == mentionedUsers &&
        other.moderation == moderation &&
        other.object == object &&
        other.ownBookmarks == ownBookmarks &&
        other.ownReactions == ownReactions &&
        other.parent == parent &&
        other.poll == poll &&
        other.popularity == popularity &&
        other.reactionCount == reactionCount &&
        other.reactionGroups == reactionGroups &&
        other.score == score &&
        other.searchData == searchData &&
        other.shareCount == shareCount &&
        other.text == text &&
        other.type == type &&
        other.updatedAt == updatedAt &&
        other.user == user &&
        other.visibility == visibility &&
        other.visibilityTag == visibilityTag;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      attachments,
      bookmarkCount,
      commentCount,
      comments,
      createdAt,
      currentFeed,
      custom,
      deletedAt,
      editedAt,
      expiresAt,
      feeds,
      filterTags,
      id,
      interestTags,
      latestReactions,
      location,
      mentionedUsers,
      moderation,
      object,
      ownBookmarks,
      ownReactions,
      parent,
      poll,
      popularity,
      reactionCount,
      reactionGroups,
      score,
      searchData,
      shareCount,
      text,
      type,
      updatedAt,
      user,
      visibility,
      visibilityTag,
    ]);
  }
}
