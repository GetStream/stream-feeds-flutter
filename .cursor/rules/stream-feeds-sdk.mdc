---
description: Stream Feeds Dart SDK architecture and implementation guidelines
globs: ["**/*.dart"]
alwaysApply: true
---

# Stream Feeds Dart SDK - Implementation Architecture

Build a production-grade pure Dart SDK for Stream Feeds API v3 with real-time activity feeds and social interactions.

## Architecture Overview

This is a **pure Dart SDK** for the Stream Feeds API v3. The SDK provides real-time activity feeds, social interactions, and state management for any Dart application environment.

### Core Design Principles

- **Pure Dart**: No platform dependencies, runs on Dart VM, Flutter, and Dart Web
- **Type Safety**: Leverages Dart null safety and strong typing
- **Reactive State**: StateNotifier-based state management with automatic notifications
- **Immutable Data**: @freezed models for predictable state management
- **Result Pattern**: Explicit error handling using Result types
- **Public API Focus**: Clean separation between public and internal APIs

## Layer Architecture

### Project Structure
```
lib/
├── stream_feeds.dart        # Main public API (barrel exports)
├── src/
│   ├── client/             # Client implementation and factory
│   ├── core/               # Models, queries, and domain logic
│   ├── data/               # Repository implementations and API clients
│   ├── presentation/       # StateNotifier-based state management
│   └── state_objects/      # High-level state objects (Feed, ActivityList)
```

### Layer Responsibilities

#### **Core Layer** (`lib/src/core/`)
- **Models**: Immutable data classes using @freezed
- **Queries**: Type-safe query specifications
- **Domain Logic**: Business rules and validation

#### **Data Layer** (`lib/src/data/`)
- **Repositories**: Data access with Result pattern
- **API Clients**: OpenAPI-generated HTTP client integration
- **Mappers**: Extension functions for data transformation

#### **Presentation Layer** (`lib/src/presentation/`)
- **State Management**: StateNotifier implementations
- **State Classes**: @freezed state definitions
- **Real-time Handlers**: WebSocket event processing

#### **State Objects Layer** (`lib/src/state_objects/`)
- **Feed**: High-level feed management
- **ActivityList**: Activity collection management
- **Public APIs**: Clean interfaces for SDK consumers

## Data Model Architecture

### Immutable Data Classes
All data models use @freezed with Dart's mixed mode syntax:

```dart
@includeInBarrelFile
@freezed
class ActivityData with _$ActivityData {
  const ActivityData({
    required this.id,
    required this.verb,
    required this.actor,
    required this.object,
    this.target,
    required this.time,
    this.extraData,
    // ... other fields
  });

  @override
  final String id;
  @override
  final String verb;
  @override
  final String actor;
  // ... field definitions with @override annotations
}
```

### Query System
Type-safe queries for API operations:

```dart
@freezed
class FeedQuery with _$FeedQuery {
  const FeedQuery({
    required this.fid,
    this.activityFilter,
    this.activityLimit,
    this.watch = true,
    // ... other parameters
  });

  @override
  final FeedId fid;
  @override
  final Filter? activityFilter;
  @override
  final int? activityLimit;
  @override
  final bool watch;
  // ... other fields with @override annotations
}
```

## State Management Architecture

### StateNotifier Pattern
Reactive state management with automatic change notifications:

```dart
class FeedStateNotifier extends StateNotifier<FeedState> {
  FeedStateNotifier({
    required this.repository,
    required FeedState initialState,
  }) : super(initialState);
  
  final FeedsRepository repository;
  
  Future<void> refresh() async {
    // Handle Result types with pattern matching
    final result = await repository.getOrCreateFeed(state.feedQuery);
    
    switch (result) {
      case Success(value: final feedData):
        state = state.copyWith(activities: feedData.activities.items);
      case Failure(error: final error):
        state = state.copyWith(error: error.toString());
    }
  }
}
```

### State Composition
Complex states built from simpler components:

```dart
@freezed
class FeedState with _$FeedState {
  const FeedState({
    required this.fid,
    required this.feedQuery,
    this.activities = const [],
    this.feedData,
    this.activitiesPagination,
    this.isLoading = false,
    this.error,
  });

  @override
  final FeedId fid;
  @override
  final FeedQuery feedQuery;
  @override
  final List<ActivityData> activities;
  @override
  final FeedData? feedData;
  @override
  final PaginationData? activitiesPagination;
  @override
  final bool isLoading;
  @override
  final String? error;
}
```

## Repository Pattern

### Result-Based Data Access
All repository methods return Result types for explicit error handling:

```dart
class FeedsRepository {
  FeedsRepository({required this.apiClient});
  
  final api.DefaultApi apiClient;
  
  Future<Result<GetOrCreateFeedData>> getOrCreateFeed(FeedQuery query) async {
    // Early return for validation
    if (!query.isValid) {
      return Result.failure(ValidationException('Invalid query'));
    }

    try {
      final result = await apiClient.getOrCreateFeed(/*...*/);
      return Result.success(GetOrCreateFeedData(
        activities: result.toPaginatedActivityData(),
      ));
    } catch (e) {
      return Result.failure(_mapClientException(e));
    }
  }
}
```

### Data Mapping Strategy
Extension functions for clean model transformations:

```dart
// API response to domain model
extension GetOrCreateFeedResponseMapper on api.GetOrCreateFeedResponse {
  PaginationResult<ActivityData> toPaginatedActivityData() {
    return PaginationResult(
      items: activities.map((e) => e.toModel()).toList(),
      pagination: PaginationData(next: next, previous: prev),
    );
  }
}

// Domain model to API request
extension FeedQueryMapper on FeedQuery {
  api.GetOrCreateFeedRequest toRequest() {
    return api.GetOrCreateFeedRequest(watch: watch);
  }
}
```

## Error Handling System

### Result Pattern Implementation
Using Dart's built-in Result type for comprehensive error handling:

```dart
extension ResultExtensions<T> on Result<T> {
  R when<R>({
    required R Function(T data) success,
    required R Function(Object error, StackTrace stackTrace) failure,
  }) {
    return switch (this) {
      Success(value: final data) => success(data),
      Failure(error: final error, stackTrace: final stackTrace) => 
          failure(error, stackTrace),
    };
  }
}
```

### Exception Hierarchy
Domain-specific exceptions for clear error handling:

```dart
sealed class StreamFeedsException implements Exception {
  const StreamFeedsException(this.message);
  final String message;
}

class NetworkException extends StreamFeedsException { /* ... */ }
class AuthenticationException extends StreamFeedsException { /* ... */ }
class ValidationException extends StreamFeedsException { /* ... */ }
```

## Real-time Architecture

### WebSocket Integration
Real-time updates through WebSocket events:

```dart
void _setupEventListeners() {
  _eventBus.eventsOfType<ActivityAddedEvent>()
      .where((event) => event.feedId == fid)
      .listen(_handleActivityAddedEvent);
}
```

### Event Processing
Structured event handling with pattern matching:

```dart
void _handleEvent(FeedsWsEvent event) {
  switch (event) {
    case ActivityAddedEvent(:final activity):
      _handleActivityAdded(activity);
    case ActivityUpdatedEvent(:final activity):
      _handleActivityUpdated(activity);
    case ActivityDeletedEvent(:final activityId):
      _handleActivityDeleted(activityId);
  }
}
```

## API v3 Feature Support

### Comments API Integration
- Reddit-style threading and voting
- Nested comment replies with depth tracking
- Comment reactions and @mentions
- Real-time comment updates via WebSocket

### Advanced Social Features
- **Stories**: Ephemeral content with expiration
- **Polls**: Interactive polling with vote tracking
- **Bookmarking**: Save and organize activities
- **For-You Feeds**: Multi-source aggregation with ranking
- **Feed Members**: Membership and access controls
- **Activity Search**: Advanced search and filtering

## Client Integration Patterns

### SDK Initialization
```dart
final client = StreamFeedsClient(
  apiKey: ApiKey('your-api-key'),
  user: User(id: 'user-123', extraData: {'name': 'John'}),
  tokenProvider: UserTokenProvider.static('user-token'),
);

await client.connect();
```

### Feed Operations
```dart
final feed = client.feed(FeedId(group: 'user', id: 'john'));

// Listen to state changes
feed.addListener(() {
  print('Activities: ${feed.state.activities.length}');
});

// Add activity
final result = await feed.addActivity(FeedAddActivityRequest(
  verb: 'post',
  object: 'picture:1',
  extraData: {'message': 'Check out this picture!'},
));
```

## Testing Strategy

### Public API Focus
Test only through public SDK interfaces - repository implementations are tested via StreamFeedsClient public API:

```dart
// Use HTTP interceptors instead of repository mocks
void main() {
  group('StreamFeedsClient', () {
    late StreamFeedsClient client;
    late HttpClientInterceptor interceptor;
    
    setUp(() {
      interceptor = HttpClientInterceptor();
      client = StreamFeedsClient(
        httpClient: createHttpClientWithInterceptor(interceptor),
      );
    });
    
    test('should create feed successfully', () async {
      interceptor.mockResponse('/feeds', {'id': 'feed-1'});
      final result = await client.feed(FeedId(group: 'user', id: 'test'));
      // ... assertions
    });
  });
}
```

## Performance Architecture

### Memory Management
- Automatic cleanup and disposal patterns
- Activity list trimming (max 1000 items)
- Efficient pagination with cursor-based loading
- Resource pooling for network connections

### Network Efficiency
- Request batching for bulk operations
- Connection pooling (max 5 concurrent)
- Circuit breaker for unhealthy endpoints

### Real-time Features
- WebSocket connection management and reconnection
- Event filtering and routing
- Optimistic updates for better UX
- Background sync for offline scenarios

## Development Guidelines

### Code Organization Standards
- **Immutable Models**: Use @freezed for all data classes with required id fields
- **State Objects**: StateNotifier-based reactive patterns
- **Query Classes**: Separate query specifications from data models
- **Repository Classes**: Concrete repository classes with OpenAPI-generated API client
- **Data Mapping**: Use extension functions with `.toModel()` instead of mapper classes
- **Public API**: Use `@includeInBarrelFile` to mark classes for public export
- **Resource Management**: Proper disposal and cleanup patterns

### Implementation Patterns
- Apply Result pattern for all async operations
- Use early return patterns for clean control flow
- Follow single responsibility principle
- Implement proper error handling and mapping
- Use constructor injection for dependencies
- Apply StateNotifier for reactive state management

## Common Implementation Patterns

### Client Factory Pattern
```dart
abstract interface class StreamFeedsClient {
  Future<void> connect();
  Future<void> disconnect();
  
  Feed feed(String group, String id);
  FeedList feedList(FeedsQuery query);
  ActivityList activityList(ActivitiesQuery query);
}
```

### State Object Pattern
```dart
class Feed {
  Stream<FeedState> get state => _state.stream;
  
  Future<Result<FeedData>> getOrCreate() async {
    final result = await _repository.getOrCreateFeed(_query);
    return result.when(
      success: (feedData) {
        _state.updateFeedData(feedData);
        return Result.success(feedData);
      },
      failure: (error) => Result.failure(error),
    );
  }
}
```

## Architectural Principles

The Stream Feeds SDK architecture emphasizes:
- **Type Safety**: Leveraging Dart's strong typing and null safety throughout
- **Reactive Patterns**: StateNotifier-based state management with automatic notifications
- **Immutable Data**: @freezed models for predictable state management
- **Error Resilience**: Result patterns and comprehensive error handling
- **Real-time Capability**: WebSocket integration for live updates and events
- **Clean Architecture**: Clear separation between public APIs and internal implementation
- **Performance Focus**: Memory management, efficient pagination, and optimized networking
- **Developer Experience**: Intuitive APIs with comprehensive documentation and examples