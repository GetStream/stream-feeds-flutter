---
description: Structured development approach for complex tasks
globs: ["**/*.dart"]
alwaysApply: false
---

# PlanIt Mode - Structured Development Approach

This rule provides a systematic approach to complex development tasks, ensuring thorough planning before implementation.

## When to Apply

Apply this methodology when:
- User message starts with "PlanIt:"
- Complex features requiring multiple steps
- Tasks affecting multiple files/systems
- Architecture changes or refactoring
- Integration of new technologies
- Adding new SDK features or capabilities

## Process Flow

### 1. Analysis Phase (STOP AND PLAN FIRST)
**Critical**: Do NOT start implementing until analysis is complete.

**Requirements Analysis**:
- Parse and clarify user requirements
- Identify scope and constraints
- Review relevant codebase sections
- Analyze existing Stream Feeds SDK patterns
- Document assumptions and dependencies
- Suggest clarifications if needed

**Impact Assessment**:
- Identify affected components and layers
- Consider backwards compatibility with API v3
- Evaluate performance implications
- Assess public API changes
- Consider testing requirements
- Review barrel file exports needed

### 2. Planning Phase
**Create structured plan in `.cursor_tasks/<task_name>.md`**:

```markdown
# Task: [Descriptive Task Name]
Created: [YYYY-MM-DD]

## Overview
[Detailed description of what needs to be accomplished and why]

## Requirements
- [ ] Requirement 1
- [ ] Requirement 2

## Action Plan
- [ ] Step 1: [Detailed description]
  - [ ] Substep 1.1
  - [ ] Substep 1.2
- [ ] Step 2: [Detailed description]
- [ ] Step 3: [Detailed description]

## Technical Considerations
- Architecture impacts (core/data/presentation layers)
- Dependencies to add/update (melos.yaml)
- @freezed models and Result types needed
- StateNotifier patterns required
- Public API changes (@includeInBarrelFile)
- Testing strategy (public API focus)
- Documentation updates

## SDK-Specific Considerations
- Pure Dart compatibility (VM, Flutter, Web)
- OpenAPI client integration
- WebSocket real-time updates
- Pattern matching usage
- Early return patterns
- Error handling with Result types
- Code generation requirements

## Progress Log
- [YYYY-MM-DD HH:MM] Task created
```

**Get Explicit Approval**: 
STOP and ask: "Does this plan look good? Should I proceed with implementation?"

### 3. Implementation Phase
**Only after user approval**:
- Execute planned steps sequentially
- Follow Stream Feeds SDK patterns consistently
- Update progress log continuously
- Apply cursor rules automatically
- Document decisions and discoveries
- Adapt plan as needed (with user notification)

### 4. Learning Phase
**Continuous improvement**:
- Document lessons learned
- Update cursor rules if patterns emerge
- Note successful approaches for future use
- Consider impact on SDK architecture

## Best Practices

### Communication
- Be explicit about what you're doing and why
- Provide context for all decisions
- Seek clarification for ambiguous requirements
- Regular progress updates for long tasks
- Explain SDK pattern choices

### Planning Quality
- Break complex tasks into manageable steps
- Consider edge cases and error scenarios
- Plan for testing and validation (public API focus)
- Include documentation updates
- Consider barrel file exports
- Plan Result type error handling

### Execution Discipline
- Follow the plan but adapt when necessary
- Apply SDK coding standards consistently
- Document all changes and reasons
- Test incrementally when possible
- Validate each step before proceeding
- Use pattern matching and early returns

### Documentation
- Keep the task file updated throughout
- Document not just what was done, but why
- Include troubleshooting notes for future reference
- Update project documentation as needed
- Document public API changes

## Integration with Stream Feeds SDK Development

For this project specifically:
- Consider impact on public API stability
- Plan for pure Dart compatibility (all environments)
- Include integration testing with OpenAPI client
- Consider real-time WebSocket implications
- Plan for StateNotifier reactive patterns
- Include performance testing for SDK overhead
- Plan @freezed model updates and migrations
- Consider melos mono repo dependencies
- Plan barrel file export updates

## Stream Feeds SDK Patterns to Follow

When implementing:
- Use `@freezed` mixed mode for data classes
- Return `Result<T>` from all repository methods
- Apply early return patterns consistently
- Use pattern matching with `switch` expressions
- Mark public APIs with `@includeInBarrelFile`
- Follow enhanced enum vs sealed class guidelines
- Use const constructors where possible
- Implement proper disposal patterns

## Success Criteria

A successful PlanIt execution should result in:
- ✅ Clear, approved plan before implementation
- ✅ Systematic execution with progress tracking
- ✅ Complete documentation of changes
- ✅ Working, tested implementation following SDK patterns
- ✅ Updated project documentation
- ✅ Proper barrel file exports for public APIs
- ✅ All new code follows cursor rules
- ✅ Result types and error handling implemented
- ✅ Pattern matching used where appropriate
- ✅ Lessons learned documented for future use

## Example Usage

```
PlanIt: Add support for activity bookmarking in the Stream Feeds SDK

This should include:
- BookmarkData model
- Repository methods for bookmark operations
- StateNotifier for bookmark state management
- Real-time bookmark events via WebSocket
- Public API for consumers to use
```

The system will then stop, analyze requirements, create a structured plan, and ask for approval before implementing.