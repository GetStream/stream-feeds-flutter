---
description: Reactive state management with StateNotifier patterns
globs: ["**/*_state.dart", "**/*_notifier.dart", "**/state/*.dart"]
alwaysApply: true
---

# State Management - Reactive StateNotifier Patterns

Build reactive, immutable state management using StateNotifier with comprehensive Result handling and real-time updates.

## When to Apply

Use these guidelines when:
- Creating reactive state objects for UI components
- Managing complex application state with StateNotifier
- Implementing real-time data synchronization
- Building pagination and loading state management
- Handling Result types from repositories

## Core Principles

- ✅ **High-Level State Objects**: Use Feed, FeedList, MemberList as public interfaces
- ✅ **Immutable State**: All state classes use @freezed with const constructors
- ✅ **Reactive Updates**: StateNotifier for automatic change notifications
- ✅ **Result Handling**: Pattern matching for success/failure states
- ✅ **Early Returns**: Apply early return patterns for efficiency
- ✅ **Event Handling**: Dedicated event handlers for real-time updates
- ✅ **Resource Management**: Proper disposal and cleanup patterns

## Architecture Overview

The Stream Feeds SDK uses a layered state management architecture:

```
High-Level State Object (Feed, FeedList, MemberList)
    ↓
StateNotifier (FeedStateNotifier, FeedListStateNotifier)
    ↓
@freezed State Class (FeedState, FeedListState)
    ↓
Event Handler (FeedEventHandler, FeedListEventHandler)
```

## Implementation Guide

### Step 1: High-Level State Objects

Create public interfaces that encapsulate StateNotifier complexity:

```dart
/// A list of feeds with a query and state.
///
/// The primary interface for working with feed lists in the Stream Feeds SDK that provides
/// functionality for querying and managing collections of feeds with pagination support.
///
/// Each feed list instance is associated with a specific query and maintains its own state
/// that can be observed for real-time updates. The feed list state includes feeds and
/// pagination information.
class FeedList with Disposable {
  @internal
  FeedList({
    required this.query,
    required this.repository,
    required this.eventsEmitter,
  }) {
    _stateNotifier = FeedListStateNotifier(
      initialState: const FeedListState(),
    );

    // Attach event handlers for real-time updates
    final handler = FeedListEventHandler(state: _stateNotifier);
    _eventsSubscription = eventsEmitter.on(handler.handleEvent);
  }

  final FeedsQuery query;
  final FeedsRepository repository;

  late final FeedListStateNotifier _stateNotifier;

  StateNotifier<FeedListState> get state => _stateNotifier;
  Stream<FeedListState> get stream => _stateNotifier.stream;

  final SharedEmitter<WsEvent> eventsEmitter;
  StreamSubscription<WsEvent>? _eventsSubscription;

  @override
  void dispose() {
    _eventsSubscription?.cancel();
    _stateNotifier.dispose();
    super.dispose();
  }

  /// Queries the initial list of entities based on the provided query.
  ///
  /// Returns a [Result] containing a list of feeds or an error.
  Future<Result<List<FeedData>>> get() => _queryFeeds(query);

  /// Loads more feeds if available.
  ///
  /// Returns a [Result] containing additional feeds or an error.
  Future<Result<List<FeedData>>> queryMore({int? limit}) async {
    final next = _stateNotifier.state.pagination?.next;

    // Early return if no more entities available
    if (next == null) return const Result.success([]);

    final nextQuery = query.copyWith(
      limit: limit ?? query.limit,
      next: next,
      previous: null,
    );

    return _queryEntities(nextQuery);
  }

  // Internal method to query entities and update state.
  Future<Result<List<EntityData>>> _queryEntities(EntityQuery query) async {
    final result = await repository.queryEntities(query);

    return result.when(
      success: (entitiesData) {
        _stateNotifier.onQueryMoreEntities(
          entitiesData,
          QueryConfiguration(
            filter: query.filter,
            sort: query.sort ?? EntitySort.defaultSort,
          ),
        );

        return Result.success(entitiesData.items);
      },
      failure: Result.failure,
    );
  }
}
```

### Step 2: Immutable State Definition

Create state classes using Freezed 3.0 mixed mode:

```dart
/// An observable state object that manages the current state of a [entity] list.
///
/// Maintains the current list of entities and pagination information for
/// efficient loading and navigation through entity collections.
@freezed
class EntityListState with _$EntityListState {
  const EntityListState({
    this.entities = const [],
    this.pagination,
  });

  /// All the paginated entities currently loaded.
  ///
  /// This list contains all entities that have been fetched across multiple
  /// pagination requests. The entities are automatically sorted according to
  /// the current sorting configuration.
  @override
  final List<EntityData> entities;

  /// Last pagination information.
  ///
  /// Contains the next and previous cursors for pagination, allowing for
  /// efficient navigation through the complete entity collection.
  @override
  final PaginationData? pagination;

  /// Indicates whether there are more entities available to load.
  bool get canLoadMore => pagination?.next != null;
}
```

### Step 3: StateNotifier Implementation

Build reactive state managers with Result pattern handling:

```dart
/// Manages the state of a [entity] list and handles state updates.
///
/// Provides methods to update the entity list state in response to data changes
/// and real-time events from the Stream Feeds API.
class EntityListStateNotifier extends StateNotifier<EntityListState> {
  EntityListStateNotifier({
    required EntityListState initialState,
  }) : super(initialState);

  QueryConfiguration<EntitySort>? _queryConfig;
  List<EntitySort> get entitySorting {
    return _queryConfig?.sort ?? EntitySort.defaultSort;
  }

  /// Handles the result of a query for more entities.
  void onQueryMoreEntities(
    PaginationResult<EntityData> result,
    QueryConfiguration<EntitySort> queryConfig,
  ) {
    _queryConfig = queryConfig;

    // Merge the new entities with the existing ones (keeping the sort order)
    final updatedEntities = state.entities.merge(
      result.items,
      key: (it) => it.id,
      compare: entitySorting.compare,
    );

    state = state.copyWith(
      entities: updatedEntities,
      pagination: result.pagination,
    );
  }

  /// Handles updates to a specific entity.
  void onEntityUpdated(EntityData entity) {
    final updatedEntities = state.entities.map((it) {
      if (it.id != entity.id) return it;
      return entity;
    }).toList();

    state = state.copyWith(entities: updatedEntities);
  }

  /// Handles removal of an entity by ID.
  void onEntityRemoved(String entityId) {
    final updatedEntities = state.entities.where((it) {
      return it.id != entityId;
    }).toList();

    state = state.copyWith(entities: updatedEntities);
  }

  /// Handles updates to multiple entities.
  void onEntitiesUpdated(ModelUpdates<EntityData> updates) {
    // Replace existing entities with updated ones
    var updatedEntities = state.entities.batchReplace(
      updates.updated,
      key: (it) => it.id,
    );

    // Remove entities by their IDs
    updatedEntities = updatedEntities.whereNot((it) {
      return updates.removedIds.contains(it.id);
    }).toList();

    state = state.copyWith(entities: updatedEntities);
  }

  /// Clears the current entity list state.
  void clear() => state = const EntityListState();
}
```

### Step 4: Event Handling System

Create dedicated event handlers for real-time updates:

```dart
class EntityListEventHandler implements StateEventHandler {
  const EntityListEventHandler({
    required this.state,
  });

  final EntityListStateNotifier state;

  @override
  void handleEvent(WsEvent event) {
    if (event is api.EntityUpdatedEvent) {
      return state.onEntityUpdated(event.entity.toModel());
    }

    if (event is api.EntityDeletedEvent) {
      return state.onEntityRemoved(event.entityId);
    }

    // Handle other events if needed
  }
}
```

### Step 5: Complex Event Handler with Early Returns

For feed-specific handlers that need filtering, use early return patterns:

```dart
class FeedEventHandler implements StateEventHandler {
  const FeedEventHandler({
    required this.fid,
    required this.state,
  });

  final FeedId fid;
  final FeedStateNotifier state;

  @override
  void handleEvent(WsEvent event) {
    if (event is api.ActivityAddedEvent) {
      if (event.fid != fid.rawValue) return;
      return state.onActivityAdded(event.activity.toModel());
    }

    if (event is api.ActivityDeletedEvent) {
      if (event.fid != fid.rawValue) return;
      return state.onActivityRemoved(event.activity.toModel());
    }

    if (event is api.ActivityMarkEvent) {
      if (event.fid != fid.rawValue) return;
      return state.onActivityMarked(event.toModel());
    }

    // Member events are already handled in MemberListEventHandler
    if (event is api.FeedMemberRemovedEvent) return;
    if (event is api.FeedMemberUpdatedEvent) return;

    // Handle other events if necessary
  }
}
```

## State Operations Patterns

### Pagination with Early Returns

```dart
/// Loads more entities if available.
///
/// Returns a [Result] containing additional entities or an error.
Future<Result<List<EntityData>>> queryMore({int? limit}) async {
  final next = _stateNotifier.state.pagination?.next;

  // Early return if no more entities available
  if (next == null) return const Result.success([]);

  final nextQuery = query.copyWith(
    limit: limit ?? query.limit,
    next: next,
    previous: null,
  );

  return _queryEntities(nextQuery);
}
```

### State Updates with Merging

```dart
void onQueryMoreEntities(
  PaginationResult<EntityData> result,
  QueryConfiguration<EntitySort> queryConfig,
) {
  _queryConfig = queryConfig;

  // Merge the new entities with the existing ones (keeping the sort order)
  final updatedEntities = state.entities.merge(
    result.items,
    key: (it) => it.id,
    compare: entitySorting.compare,
  );

  state = state.copyWith(
    entities: updatedEntities,
    pagination: result.pagination,
  );
}
```

### Batch Updates

```dart
/// Handles updates to multiple entities.
void onEntitiesUpdated(ModelUpdates<EntityData> updates) {
  // Replace existing entities with updated ones
  var updatedEntities = state.entities.batchReplace(
    updates.updated,
    key: (it) => it.id,
  );

  // Remove entities by their IDs
  updatedEntities = updatedEntities.whereNot((it) {
    return updates.removedIds.contains(it.id);
  }).toList();

  state = state.copyWith(entities: updatedEntities);
}
```

## Resource Management

### Disposal Pattern

```dart
@override
void dispose() {
  _eventsSubscription?.cancel();
  _stateNotifier.dispose();
  super.dispose();
}
```

### Event Subscription Management

```dart
@internal
EntityList({
  required this.query,
  required this.repository,
  required this.eventsEmitter,
}) {
  _stateNotifier = EntityListStateNotifier(
    initialState: const EntityListState(),
  );

  // Attach event handlers for real-time updates
  final handler = EntityListEventHandler(state: _stateNotifier);
  _eventsSubscription = eventsEmitter.on(handler.handleEvent);
}
```

## Testing Patterns

### Public API Testing Focus

Test only through public SDK interfaces:

```dart
void main() {
  group('Entity List State Management', () {
    late StreamFeedsClient client;
    late HttpClientInterceptor interceptor;
    late EntityList entityList;
    
    setUp(() {
      interceptor = HttpClientInterceptor();
      client = StreamFeedsClient(
        httpClient: createHttpClientWithInterceptor(interceptor),
      );
      entityList = client.entityList(EntityQuery(/*...*/));
    });
    
    tearDown(() {
      entityList.dispose();
    });
    
    test('should load entities through public API', () async {
      // Arrange - Mock HTTP response
      interceptor.mockResponse('/entities', {
        'items': [
          {'id': '1', 'name': 'Entity 1'},
          {'id': '2', 'name': 'Entity 2'},
        ],
        'next': null,
      });
      
      // Act - Use public API
      final result = await entityList.get();
      
      // Assert - Test public state
      expect(result.isSuccess, isTrue);
      expect(entityList.state.value.entities.length, equals(2));
    });
  });
}
```

## Documentation Standards

### State Object Documentation

Follow these documentation patterns for consistency across all state management components:

#### Class Documentation for State Objects

**High-level State Objects (Feed, ActivityList, etc.)**:
```dart
/// Represents a [entity] with a query and state.
///
/// The primary interface for working with [entity type] in the Stream Feeds SDK that provides
/// functionality for [key capabilities] with [key features] support.
///
/// Each [entity] instance is associated with a specific query and maintains its own state
/// that can be observed for real-time updates. The [entity] state includes [main data types].
///
/// Example usage:
/// ```dart
/// final feed = client.feed(FeedId(group: 'user', id: 'john'));
/// 
/// // Listen to state changes
/// feed.addListener(() {
///   print('Activities: ${feed.state.activities.length}');
/// });
/// 
/// // Perform operations
/// await feed.refresh();
/// ```
class Feed extends Disposable { ... }
```

**@freezed State Classes**:
```dart
/// An observable state object that manages the current state of a [entity].
///
/// Maintains the current [primary data] and [supporting data] for
/// efficient [key operations] through [data collections].
@freezed
class FeedState with _$FeedState { ... }
```

**StateNotifier Classes**:
```dart
/// Manages the state of a [entity] and handles state updates.
///
/// Provides methods to update the [entity] state in response to data changes,
/// user interactions, and real-time events from the Stream Feeds API.
class FeedStateNotifier extends StateNotifier<FeedState> { ... }
```

#### Method Documentation

Use concise, action-oriented documentation for all state object methods:

```dart
/// [Action description] based on the provided [ParameterType].
///
/// Returns a [Result] containing [return type] or an error.
Future<Result<T>> methodName(ParameterType parameter) async { ... }

/// [Action description] for the current [entity].
///
/// This method [behavior description] and [side effects].
void methodName() { ... }
```

**Examples**:
```dart
/// Queries the initial list of entities based on the provided query.
///
/// Returns a [Result] containing a list of entities or an error.
Future<Result<List<EntityData>>> get() async { ... }

/// Refreshes the entity content from the server.
///
/// This method clears any existing error state and fetches the latest data.
Future<void> refresh() async { ... }
```

#### State Field Documentation

**Primary Collections**:
```dart
/// All the paginated [items] currently loaded.
///
/// This list contains all [items] that have been fetched across multiple
/// pagination requests. The [items] are automatically sorted according to
/// the current sorting configuration.
@override
final List<ItemData> items;
```

**Pagination Fields**:
```dart
/// Last pagination information.
///
/// Contains the next and previous cursors for pagination, allowing for
/// efficient navigation through the complete [entity] collection.
@override
final PaginationData? pagination;
```

**State Flags**:
```dart
/// Indicates whether there are more [items] available to load.
bool get canLoadMore => pagination?.next != null;
```

#### Pattern Distinctions

**Feed vs List Types**:
- **Feed**: Single entity with activities and metadata
- **List**: Collection of entities with pagination

**Documentation Patterns**:
- Feed: "Represents a feed..." 
- List: "Represents a list of [entities]..."
- State: "An observable state object that manages..."
- Notifier: "Manages the state of a [entity] and handles state updates..."

### Documentation Checklist

When documenting state management components, ensure:

- [ ] Used appropriate class documentation pattern (Feed vs List vs State vs Notifier)
- [ ] Included concise method documentation with action-oriented descriptions
- [ ] Added comprehensive field documentation for state properties
- [ ] Included code examples for high-level state objects
- [ ] Distinguished between Feed and List documentation patterns
- [ ] Used consistent terminology throughout
- [ ] Added "Returns a [Result]..." for async methods
- [ ] Described pagination and state management behavior

## Best Practices Checklist

When implementing state management, ensure:

- [ ] Used high-level state objects as public interfaces
- [ ] Used `@freezed` with mixed mode syntax for state classes
- [ ] Added `const` constructors for performance
- [ ] Implemented Result pattern handling with pattern matching
- [ ] Applied early return patterns for efficiency
- [ ] Used dedicated event handlers for real-time updates
- [ ] Implemented proper disposal in state objects
- [ ] Added state validation extensions where needed
- [ ] Used `@internal` for StateNotifier constructors
- [ ] Followed consistent naming patterns

## Common State Patterns

### Basic List State
```dart
@freezed
class ActivityListState with _$ActivityListState {
  const ActivityListState({
    this.activities = const [],
    this.pagination,
  });

  @override
  final List<ActivityData> activities;
  @override
  final PaginationData? pagination;

  bool get canLoadMore => pagination?.next != null;
}
```

### Entity State with Metadata
```dart
@freezed
class FeedState with _$FeedState {
  const FeedState({
    this.activities = const [],
    this.feedData,
    this.pagination,
  });

  @override
  final List<ActivityData> activities;
  @override
  final FeedData? feedData;
  @override
  final PaginationData? pagination;

  bool get canLoadMore => pagination?.next != null;
}
```

### Complex State with Multiple Collections
```dart
@freezed
class MemberListState with _$MemberListState {
  const MemberListState({
    this.members = const [],
    this.pagination,
  });

  @override
  final List<FeedMemberData> members;
  @override
  final PaginationData? pagination;

  bool get canLoadMore => pagination?.next != null;
}
```

## Success Criteria

A well-designed state management system should:
- ✅ Use high-level state objects as public interfaces
- ✅ Use immutable state with @freezed classes
- ✅ Handle Result types with pattern matching
- ✅ Apply early return patterns consistently
- ✅ Include dedicated event handlers for real-time updates
- ✅ Implement proper resource disposal
- ✅ Support efficient pagination and data merging
- ✅ Follow consistent documentation patterns for all components
- ✅ Provide clear, action-oriented method documentation
- ✅ Include comprehensive state field documentation
- ✅ Test only through public APIs, not internal StateNotifier implementations