---
description: Type-safe query specifications for Stream Feeds API
globs: ["**/*_query.dart", "**/queries/*.dart"]
alwaysApply: true
---

# Query Specifications - Type-Safe API Queries

Build robust, reusable query objects for Stream Feeds API operations with comprehensive filtering and pagination.

## When to Apply

Use these guidelines when:
- Creating API query classes (`*Query` classes)
- Building search and filter functionality
- Implementing pagination in feeds
- Defining query parameters for repositories
- Converting legacy query patterns

## Core Principles

- ✅ **Type Safety**: Use strong typing for all query parameters
- ✅ **Immutable**: All query classes use @freezed with const constructors
- ✅ **Flexible Parameters**: Balance required vs optional parameters based on API needs
- ✅ **Mapping Friendly**: Design for easy conversion to API requests
- ✅ **Pattern Matching**: Support destructuring and switch expressions
- ✅ **Organized Structure**: Use region comments and consistent organization

## Implementation Guide

### Step 1: Basic Query Structure

Use Freezed 3.0 mixed mode for clean query classes:

```dart
/// A query for retrieving activities with filtering, sorting, and pagination.
///
/// Supports comprehensive activity discovery by content, time ranges, and social metrics.
/// Includes flexible filtering options and efficient pagination.
///
/// ## Example
/// ```dart
/// final query = ActivitiesQuery(
///   filter: Filter.equal(ActivitiesFilterField.type, "post"),
///   sort: [ActivitiesSort.desc(ActivitiesSortField.createdAt)],
///   limit: 20,
/// );
/// ```
@freezed
class ActivitiesQuery with _$ActivitiesQuery {
  const ActivitiesQuery({
    this.filter,
    this.sort,
    this.limit,
    this.next,
    this.previous,
  });

  /// The filter to apply to the activities query.
  @override
  final Filter? filter;

  /// The sorting criteria to apply to the activities.
  @override
  final List<ActivitiesSort>? sort;

  /// The maximum number of activities to return.
  @override
  final int? limit;

  /// The next page cursor for pagination.
  @override
  final String? next;

  /// The previous page cursor for pagination.
  @override
  final String? previous;
}
```

### Step 2: Required vs Optional Field Guidelines

Follow these patterns for field requirements:

```dart
// Pattern 1: Entity-specific queries (require identifier)
@freezed
class MembersQuery with _$MembersQuery {
  const MembersQuery({
    required this.fid,  // Required: need to know which feed
    this.filter,        // Optional: can query all members
    this.sort,          // Optional: has sensible defaults
    this.limit,         // Optional: API has defaults
    this.next,          // Optional: pagination
    this.previous,      // Optional: pagination
  });
  // ...
}

// Pattern 2: Global queries (all optional)
@freezed
class ActivitiesQuery with _$ActivitiesQuery {
  const ActivitiesQuery({
    this.filter,        // Optional: can query all activities
    this.sort,          // Optional: has sensible defaults
    this.limit,         // Optional: API has defaults
    this.next,          // Optional: pagination
    this.previous,      // Optional: pagination
  });
  // ...
}

// Pattern 3: Collection queries (mixed requirements)
@freezed
class FeedsQuery with _$FeedsQuery {
  const FeedsQuery({
    this.filter,        // Optional: can query all feeds
    this.sort,          // Optional: has sensible defaults
    this.limit,         // Optional: API has defaults
    this.next,          // Optional: pagination
    this.previous,      // Optional: pagination
    this.watch = false, // Optional with default: behavioral flag
  });
  // ...
}
```

### Step 3: Filter Fields Implementation

Use extension types with comprehensive documentation:

```dart
// region Filter

/// Represents a field that can be used in activities filtering.
///
/// This extension type provides a type-safe way to specify which field should be used
/// when creating filters for activities queries.
extension type const ActivitiesFilterField(String field) implements String {
  /// Filter by the unique identifier of the activity.
  ///
  /// **Supported operators:** `.equal`, `.in`
  static const id = ActivitiesFilterField('id');

  /// Filter by the creation timestamp of the activity.
  ///
  /// **Supported operators:** `.equal`, `.greaterThan`, `.lessThan`,
  /// `.greaterThanOrEqual`, `.lessThanOrEqual`
  static const createdAt = ActivitiesFilterField('created_at');

  /// Filter by the activity type.
  ///
  /// **Supported operators:** `.equal`, `.in`
  static const type = ActivitiesFilterField('type');

  /// Filter by the text content of the activity.
  ///
  /// **Supported operators:** `.equal`, `.customQ`, `.customAutocomplete`
  static const text = ActivitiesFilterField('text');

  /// Filter by numeric fields (e.g., reaction counts, scores).
  ///
  /// **Supported operators:** `.equal`, `.notEqual`, `.greaterThan`,
  /// `.lessThan`, `.greaterThanOrEqual`, `.lessThanOrEqual`
  static const reactionCount = ActivitiesFilterField('reaction_count');
}

// endregion
```

### Step 4: Sort Implementation Pattern

Use inheritance for type-safe sorting:

```dart
// region Sort

/// Represents a sorting operation for activities.
///
/// This class extends the base Sort functionality and provides specific
/// sorting capabilities for activity data with default configurations.
class ActivitiesSort extends Sort<ActivityData> {
  /// Creates a new activities sort with ascending direction.
  const ActivitiesSort.asc(
    ActivitiesSortField super.field, {
    super.nullOrdering = NullOrdering.nullsLast,
  }) : super.asc();

  /// Creates a new activities sort with descending direction.
  const ActivitiesSort.desc(
    ActivitiesSortField super.field, {
    super.nullOrdering = NullOrdering.nullsFirst,
  }) : super.desc();

  /// Default sorting configuration for activities.
  ///
  /// Sorts by creation time in descending order, meaning the most recent
  /// activities will appear first.
  static final List<ActivitiesSort> defaultSort = [
    ActivitiesSort.desc(ActivitiesSortField.createdAt),
  ];
}

/// Defines the fields by which activities can be sorted.
///
/// This extension type provides specific fields for sorting activity data.
/// Each field corresponds to a property of the [ActivityData] model, allowing for flexible
/// sorting options when querying activities.
extension type const ActivitiesSortField(SortField<ActivityData> field)
    implements SortField<ActivityData> {
  /// Sort by the creation timestamp of the activity.
  ///
  /// This field allows sorting activities by when they were created (newest/oldest first).
  static final createdAt = ActivitiesSortField(
    SortField('created_at', (data) => data.createdAt),
  );

  /// Sort by the update timestamp of the activity.
  ///
  /// This field allows sorting activities by when they were last updated (newest/oldest first).
  static final updatedAt = ActivitiesSortField(
    SortField('updated_at', (data) => data.updatedAt),
  );

  /// Sort by reaction count.
  ///
  /// This field allows sorting activities by popularity (highest/lowest first).
  static final reactionCount = ActivitiesSortField(
    SortField('reaction_count', (data) => data.reactionCount),
  );
}

// endregion
```

### Step 5: Request Mapping Extension

Convert queries to API requests using extension functions:

```dart
/// Extension for converting an [ActivitiesQuery] to a [api.QueryActivitiesRequest].
extension ActivitiesQueryRequest on ActivitiesQuery {
  /// Converts this activities query to an API request format.
  ///
  /// Returns a [api.QueryActivitiesRequest] suitable for making API calls to retrieve activities.
  api.QueryActivitiesRequest toRequest() {
    return api.QueryActivitiesRequest(
      filter: filter?.toRequest(),
      sort: sort?.map((s) => s.toRequest()).toList(),
      limit: limit,
      next: next,
      prev: previous,
    );
  }
}
```

## Real Implementation Examples

### Example 1: Entity-Specific Query (Members)

```dart
/// A query for retrieving feed members with filtering, sorting, and pagination.
@freezed
class MembersQuery with _$MembersQuery {
  const MembersQuery({
    required this.fid,  // Required: must specify which feed
    this.filter,
    this.sort,
    this.limit,
    this.next,
    this.previous,
  });

  @override
  final FeedId fid;
  @override
  final Filter? filter;
  @override
  final List<MembersSort>? sort;
  @override
  final int? limit;
  @override
  final String? next;
  @override
  final String? previous;
}
```

### Example 2: Global Query (Activities)

```dart
/// A query for retrieving activities with filtering, sorting, and pagination.
@freezed
class ActivitiesQuery with _$ActivitiesQuery {
  const ActivitiesQuery({
    this.filter,        // All optional - can query all activities
    this.sort,
    this.limit,
    this.next,
    this.previous,
  });

  @override
  final Filter? filter;
  @override
  final List<ActivitiesSort>? sort;
  @override
  final int? limit;
  @override
  final String? next;
  @override
  final String? previous;
}
```

### Example 3: Complex Query (Feed)

```dart
/// A query for retrieving and managing feed data from Stream Feeds.
@freezed
class FeedQuery with _$FeedQuery {
  const FeedQuery({
    required this.fid,                    // Required: feed identifier
    this.activityFilter,                  // Optional: filter activities
    this.activityLimit,                   // Optional: pagination
    this.activityNext,                    // Optional: pagination
    this.activityPrevious,                // Optional: pagination
    this.activitySelectorOptions,         // Optional: advanced options
    this.data,                           // Optional: additional data
    this.externalRanking,                // Optional: custom ranking
    this.followerLimit,                  // Optional: follower pagination
    this.followingLimit,                 // Optional: following pagination
    this.interestWeights,                // Optional: interest weights
    this.memberLimit,                    // Optional: member pagination
    this.view,                          // Optional: custom view
    this.watch = true,                  // Optional with default
  });

  @override
  final FeedId fid;
  @override
  final Filter? activityFilter;
  @override
  final int? activityLimit;
  @override
  final String? activityNext;
  @override
  final String? activityPrevious;
  @override
  final Map<String, Object>? activitySelectorOptions;
  @override
  final FeedInputData? data;
  @override
  final Map<String, Object>? externalRanking;
  @override
  final int? followerLimit;
  @override
  final int? followingLimit;
  @override
  final Map<String, double>? interestWeights;
  @override
  final int? memberLimit;
  @override
  final String? view;
  @override
  final bool watch;
}
```

## Query Organization Patterns

### File Structure

```dart
// Standard query file organization
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:stream_core/stream_core.dart';
import '../../../generated/api/models.dart' as api;

part 'entities_query.freezed.dart';

@freezed
class EntitiesQuery with _$EntitiesQuery {
  // Query definition
}

// region Filter
extension type const EntitiesFilterField(String field) implements String {
  // Filter field definitions
}
// endregion

// region Sort
class EntitiesSort extends Sort<EntityData> {
  // Sort implementation
}

extension type const EntitiesSortField(SortField<EntityData> field)
    implements SortField<EntityData> {
  // Sort field definitions
}
// endregion

extension EntitiesQueryRequest on EntitiesQuery {
  // Request mapping
}
```

### Documentation Standards

```dart
/// A query for retrieving [entities] with filtering, sorting, and pagination.
///
/// [Describe what this query does and its main use cases]. [Include specific
/// features like filtering, sorting, pagination, real-time updates].
///
/// ## Example
/// ```dart
/// final query = EntitiesQuery(
///   filter: Filter.equal(EntitiesFilterField.status, "active"),
///   sort: [EntitiesSort.desc(EntitiesSortField.createdAt)],
///   limit: 20,
/// );
/// ```
@freezed
class EntitiesQuery with _$EntitiesQuery {
  // Implementation
}
```

## Common Query Patterns

### Basic Query
```dart
final query = ActivitiesQuery(
  filter: Filter.equal(ActivitiesFilterField.type, "post"),
  limit: 20,
);
```

### Paginated Query with Sorting
```dart
final query = FeedsQuery(
  filter: Filter.greaterThan(FeedsFilterField.followerCount, 100),
  sort: [
    FeedsSort.desc(FeedsSortField.followerCount),
    FeedsSort.asc(FeedsSortField.createdAt),
  ],
  limit: 50,
  watch: true,
);
```

### Complex Query with Multiple Filters
```dart
final query = MembersQuery(
  fid: FeedId(group: 'team', id: 'developers'),
  filter: Filter.and([
    Filter.equal(MembersFilterField.status, "accepted"),
    Filter.in(MembersFilterField.role, ["admin", "moderator"]),
  ]),
  sort: MembersSort.defaultSort,
  limit: 25,
);
```

## Best Practices Checklist

When creating query specifications, ensure:

- [ ] Used `@freezed` with mixed mode syntax
- [ ] Added `const` constructor for performance
- [ ] Balanced required vs optional parameters based on API needs
- [ ] Used region comments for organization (`// region Filter`, `// endregion`)
- [ ] Implemented extension types for type-safe field definitions
- [ ] Added comprehensive documentation with supported operators
- [ ] Used inheritance for sort implementations with `defaultSort`
- [ ] Created request mapping extensions with `toRequest()`
- [ ] Followed consistent file organization patterns
- [ ] Added class documentation with examples

## Validation Patterns

### Query Validation Extensions

```dart
extension EntitiesQueryValidation on EntitiesQuery {
  /// Validates the query parameters.
  bool get isValid {
    // Add validation logic specific to your query
    if (limit != null && limit! <= 0) return false;
    if (id.isEmpty) return false;
    return true;
  }

  /// Returns validation error message if query is invalid.
  String? get validationError {
    if (limit != null && limit! <= 0) return 'Limit must be positive';
    if (id.isEmpty) return 'ID cannot be empty';
    return null;
  }
}
```

## Success Criteria

A well-designed query specification should:
- ✅ Compile without warnings with correct type definitions
- ✅ Support type-safe parameter passing with extension types
- ✅ Convert cleanly to API requests with all required fields
- ✅ Support pagination and filtering with comprehensive field options
- ✅ Use appropriate inheritance patterns for sorting
- ✅ Follow consistent naming conventions and documentation standards
- ✅ Include helpful extension methods for common operations
- ✅ Match real API field types and constraints accurately
- ✅ Provide comprehensive filter field definitions with supported operators
- ✅ Use region comments for clear code organization
- ✅ Include validation extensions where appropriate