---
description: Immutable data models with Freezed 3.0 mixed mode syntax
globs: ["**/*_data.dart", "**/models/*.dart"]
alwaysApply: true
---

# Data Models - Immutable Classes with Freezed 3.0

Create type-safe, immutable data models using Freezed 3.0 mixed mode syntax for the Stream Feeds SDK.

## When to Apply

Use these guidelines when:
- Creating domain models (`*Data` classes)
- Defining query specifications (`*Query` classes)  
- Building state objects for StateNotifier
- Designing public API data structures
- Converting legacy factory constructor syntax

## Core Principles

- ✅ **Pure Data**: No business logic, only data structure
- ✅ **Immutable**: All data classes use @freezed with const constructors
- ✅ **Type Safe**: Leverage Dart's type system and null safety
- ✅ **Pattern Matching**: Design for destructuring and switch expressions
- ✅ **Selective JSON**: Add serialization only when crossing boundaries
- ✅ **Public API**: Mark external classes with @includeInBarrelFile

## Implementation Guide

### Step 1: Basic Data Model Structure

Use Freezed 3.0 mixed mode for clean, simple syntax:

```dart
import 'package:barrel_files_annotation/barrel_files_annotation.dart';

@includeInBarrelFile  // Mark for public API
@freezed
class ActivityData with _$ActivityData {
  const ActivityData({
    // Required fields first
    required this.id,
    required this.user,
    required this.createdAt,
    required this.updatedAt,
    required this.type,
    // Optional fields
    this.text,
    this.attachments = const [],
    this.latestReactions = const [],
    this.reactionCount = 0,
    this.deletedAt,
    // Custom field always last
    this.custom,
  });

  /// The unique identifier of the activity.
  @override
  final String id;

  /// The user who created the activity.
  @override
  final UserData user;

  /// The date and time when the activity was created.
  @override
  final DateTime createdAt;

  /// The date and time when the activity was last updated.
  @override
  final DateTime updatedAt;

  /// The type or category of the activity (e.g., "post", "share", "like").
  @override
  final String type;

  /// The text content of the activity.
  @override
  final String? text;

  /// File attachments associated with the activity.
  @override
  final List<Attachment> attachments;

  /// The most recent reactions added to the activity.
  @override
  final List<FeedsReactionData> latestReactions;

  /// The total number of reactions on the activity across all reaction types.
  @override
  final int reactionCount;

  /// The date and time when the activity was deleted, if applicable.
  @override
  final DateTime? deletedAt;

  /// Custom data associated with the activity.
  @override
  final Map<String, Object>? custom;
}
```

**Note**: The `@override` annotations are required when using Freezed 3.0 mixed mode syntax because the fields are part of the generated mixin and need to be explicitly overridden.

### Step 2: Property Organization

Follow this consistent ordering pattern:

```dart
@freezed
class EntityData with _$EntityData {
  const EntityData({
    // 1. Required fields first (in logical order)
    required this.id,
    required this.createdAt,
    required this.updatedAt,
    required this.user,
    
    // 2. Optional core fields
    this.deletedAt,
    this.name,
    this.description,
    
    // 3. Collections with defaults
    this.tags = const [],
    this.attachments = const [],
    
    // 4. Numeric fields with defaults
    this.count = 0,
    this.score = 0.0,
    
    // 5. Custom field always last
    this.custom,
  });

  // Field definitions with comprehensive documentation
}
```

### Step 3: Extension Types for Constants

Use extension types for type-safe string constants:

```dart
/// Extension type representing the different status of feed members.
///
/// This extension type provides type-safe representation of common feed member
/// statuses while automatically handling any custom status values that might be
/// returned from the API.
///
/// By implementing String, it seamlessly supports both known and unknown status values.
extension type const FeedMemberStatus(String value) implements String {
  /// Represents a feed member.
  static const member = FeedMemberStatus('member');

  /// Represents a feed whose membership is pending approval.
  static const pending = FeedMemberStatus('pending');

  /// Represents a feed member whose invite has been rejected.
  static const rejected = FeedMemberStatus('rejected');

  /// Represents a feed member with an unknown status.
  static const unknown = FeedMemberStatus('unknown');
}
```

### Step 4: Enhanced Enums for Simple Cases

Use enhanced enums for closed sets of values:

```dart
@includeInBarrelFile
enum LoadingState {
  idle,
  loading,
  refreshing,
  error;
  
  bool get isLoading => this == LoadingState.loading;
  bool get isRefreshing => this == LoadingState.refreshing;
  
  String get message => switch (this) {
    LoadingState.idle => 'Ready',
    LoadingState.loading => 'Loading...',
    LoadingState.refreshing => 'Refreshing...',
    LoadingState.error => 'Error occurred',
  };
}
```

### Step 5: Data Mapping Extensions

Create extension functions for API-to-domain mapping:

```dart
/// Extension function to convert an [api.ActivityResponse] to an [ActivityData] model.
extension ActivityResponseMapper on api.ActivityResponse {
  /// Converts this API activity response to a domain [ActivityData] instance.
  ///
  /// This function maps all fields from the API response to the corresponding
  /// domain model fields with proper type conversions and null handling.
  ActivityData toModel() {
    return ActivityData(
      id: id,
      user: user.toModel(),
      createdAt: createdAt,
      updatedAt: updatedAt,
      type: type,
      text: text,
      attachments: attachments,
      latestReactions: [...latestReactions.map((r) => r.toModel())],
      reactionCount: reactionCount,
      deletedAt: deletedAt,
      custom: custom,
    );
  }
}
```

### Step 6: Data Mapping with Spread Operator

Use spread operator only when domain field is non-nullable AND you need to convert/transform the data:

```dart
extension EntityResponseMapper on api.EntityResponse {
  EntityData toModel() {
    return EntityData(
      id: id,
      
      // ✅ List spread operator: domain non-nullable + transformation needed
      members: [...?apiMembers?.map((m) => m.toModel())],
      tags: [...?apiTags?.map((t) => t.toLowerCase())],
      
      // ✅ Map spread operator: domain non-nullable + casting needed
      customData: {...?apiCustomData?.cast<String, Object>()},
      
      // ✅ For-loop spread: map transformations
      reactionGroups: {
        for (final entry in reactionGroups.entries)
          entry.key: entry.value.toModel(),
      },
      
      // ✅ Direct assignment: same types, no transformation needed
      name: name,
      description: description,
      filterTags: filterTags,  // Both List<String>, even if API is nullable
      custom: custom,          // Both Map<String, Object>?, no casting needed
      
      // ✅ Null coalescing: domain non-nullable, API nullable, same types
      count: count ?? 0,
      visibility: visibility ?? 'public',
      
      // ✅ Direct assignment: domain nullable, API nullable
      deletedAt: deletedAt,
      custom: custom,
    );
  }
}
```

### Step 7: Custom Data Field Pattern

Always use `Map<String, Object>` for custom data (not `Object?`):

```dart
@freezed
class EntityData with _$EntityData {
  const EntityData({
    required this.id,
    // ... other fields
    
    /// Custom data associated with the entity.
    this.custom,
  });

  // ... other field definitions

  /// Custom data associated with the entity.
  @override
  final Map<String, Object>? custom;  // Non-nullable Object values
}

## Pattern Matching Examples

### With Extension Types
```dart
String getMemberStatusLabel(FeedMemberStatus status) {
  return switch (status) {
    FeedMemberStatus.member => 'Active Member',
    FeedMemberStatus.pending => 'Pending Approval',
    FeedMemberStatus.rejected => 'Invite Rejected',
    FeedMemberStatus.unknown => 'Unknown Status',
    _ => 'Custom Status: ${status.value}',
  };
}
```

### With Enhanced Enums
```dart
String getLoadingMessage(LoadingState state) {
  return switch (state) {
    LoadingState.idle => 'Ready',
    LoadingState.loading => 'Loading...',
    LoadingState.refreshing => 'Refreshing...',
    LoadingState.error => 'Error occurred',
  };
}
```

### With @freezed Classes
```dart
String getActivityStatus(ActivityData activity) {
  return switch (activity) {
    ActivityData(deletedAt: final deletedAt?) => 
        'Deleted on ${deletedAt.toLocal()}',
    ActivityData(text: final text?) when text.isNotEmpty => 
        'Active with text',
    ActivityData(attachments: final attachments) when attachments.isNotEmpty => 
        'Has ${attachments.length} attachments',
    _ => 'Basic activity',
  };
}
```

## Documentation Standards

### Class Documentation

```dart
/// A [entity] in the Stream Feeds system.
///
/// [Brief description of what this entity represents and its role in the system].
/// [Description of key features and capabilities]. [Mention of real-time updates
/// or social features if applicable].
@freezed
class EntityData with _$EntityData {
  // Implementation
}
```

### Field Documentation

```dart
/// [Brief description of what this field represents].
///
/// [Additional context about usage, constraints, or special behavior if needed].
@override
final String fieldName;
```

**Examples**:
```dart
/// The unique identifier of the activity.
@override
final String id;

/// The date and time when the activity was created.
@override
final DateTime createdAt;

/// Custom data associated with the activity.
@override
final Map<String, Object>? custom;
```

## Public API Management

### What to Mark for Export
- ✅ Domain models consumed by SDK users
- ✅ Query classes for public methods
- ✅ Exception classes
- ✅ Public enums and extension types

### What to Keep Private
- ❌ Internal state objects
- ❌ Mapper utilities
- ❌ Repository implementations

```dart
// ✅ Public - Mark for export
@includeInBarrelFile
@freezed
class ActivityData with _$ActivityData {
  // Public domain model
}

// ❌ Private - Don't mark
@freezed
class InternalStateData with _$InternalStateData {
  // Internal implementation detail
}
```

## Best Practices Checklist

When creating data models, ensure:

- [ ] Used `@freezed` with mixed mode syntax
- [ ] Added `const` constructor for performance
- [ ] Required `id` field for entities
- [ ] Appropriate nullability for optional fields
- [ ] Default values for collections (`= const []`)
- [ ] Added `@override` annotations to all fields
- [ ] Custom field placed last in constructor and class
- [ ] Used `Map<String, Object>` (not `Object?`) for custom data
- [ ] `@includeInBarrelFile` for public APIs
- [ ] JSON serialization only when needed
- [ ] Pattern matching friendly structure
- [ ] Comprehensive field documentation
- [ ] Used spread operator only when domain is non-nullable AND transformation needed (`[...?items?.map()]`)

## Common Patterns

### Entity Models
```dart
@includeInBarrelFile
@freezed
class UserData with _$UserData {
  const UserData({
    required this.id,
    required this.name,
    this.avatar,
    this.extraData = const {},
    this.custom,
  });

  @override
  final String id;
  @override
  final String name;
  @override
  final String? avatar;
  @override
  final Map<String, Object> extraData;
  @override
  final Map<String, Object>? custom;
}
```

### State Models
```dart
@freezed
class FeedState with _$FeedState {
  const FeedState({
    required this.feedId,
    this.activities = const [],
    this.isLoading = false,
    this.error,
  });

  @override
  final String feedId;
  @override
  final List<ActivityData> activities;
  @override
  final bool isLoading;
  @override
  final String? error;
}
```

### Complex Entity with Relationships
```dart
@freezed
class FeedData with _$FeedData {
  const FeedData({
    required this.createdAt,
    required this.createdBy,
    required this.description,
    required this.fid,
    required this.followerCount,
    required this.followingCount,
    required this.memberCount,
    required this.name,
    required this.updatedAt,
    this.deletedAt,
    this.filterTags = const [],
    this.visibility,
    this.custom,
  });

  @override
  final DateTime createdAt;
  @override
  final UserData createdBy;
  @override
  final String description;
  @override
  final FeedId fid;
  @override
  final int followerCount;
  @override
  final int followingCount;
  @override
  final int memberCount;
  @override
  final String name;
  @override
  final DateTime updatedAt;
  @override
  final DateTime? deletedAt;
  @override
  final List<String> filterTags;
  @override
  final String? visibility;
  @override
  final Map<String, Object>? custom;
}
```

## Success Criteria

A well-designed data model should:
- ✅ Compile without warnings
- ✅ Support pattern matching
- ✅ Have clear, typed properties
- ✅ Follow naming conventions
- ✅ Be properly exported if public
- ✅ Use const constructors
- ✅ Have appropriate defaults
- ✅ Use non-nullable Object in custom data maps
- ✅ Follow consistent property organization
- ✅ Include comprehensive documentation